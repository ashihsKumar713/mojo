// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library command_buffer_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
import 'package:mojo_services/mojo/gpu_capabilities.mojom.dart' as gpu_capabilities_mojom;



class CommandBufferState extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  int numEntries = 0;
  int getOffset = 0;
  int putOffset = 0;
  int token = 0;
  int error = 0;
  int contextLostReason = 0;
  int generation = 0;

  CommandBufferState() : super(kVersions.last.size);

  CommandBufferState.init(
    int this.numEntries, 
    int this.getOffset, 
    int this.putOffset, 
    int this.token, 
    int this.error, 
    int this.contextLostReason, 
    int this.generation
  ) : super(kVersions.last.size);

  static CommandBufferState deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CommandBufferState decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CommandBufferState result = new CommandBufferState();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.numEntries = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.getOffset = decoder0.decodeInt32(12);
    }
    if (mainDataHeader.version >= 0) {
      
      result.putOffset = decoder0.decodeInt32(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.token = decoder0.decodeInt32(20);
    }
    if (mainDataHeader.version >= 0) {
      
      result.error = decoder0.decodeInt32(24);
    }
    if (mainDataHeader.version >= 0) {
      
      result.contextLostReason = decoder0.decodeInt32(28);
    }
    if (mainDataHeader.version >= 0) {
      
      result.generation = decoder0.decodeUint32(32);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CommandBufferState";
    String fieldName;
    try {
      fieldName = "numEntries";
      encoder0.encodeInt32(numEntries, 8);
      fieldName = "getOffset";
      encoder0.encodeInt32(getOffset, 12);
      fieldName = "putOffset";
      encoder0.encodeInt32(putOffset, 16);
      fieldName = "token";
      encoder0.encodeInt32(token, 20);
      fieldName = "error";
      encoder0.encodeInt32(error, 24);
      fieldName = "contextLostReason";
      encoder0.encodeInt32(contextLostReason, 28);
      fieldName = "generation";
      encoder0.encodeUint32(generation, 32);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CommandBufferState("
           "numEntries: $numEntries" ", "
           "getOffset: $getOffset" ", "
           "putOffset: $putOffset" ", "
           "token: $token" ", "
           "error: $error" ", "
           "contextLostReason: $contextLostReason" ", "
           "generation: $generation" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["numEntries"] = numEntries;
    map["getOffset"] = getOffset;
    map["putOffset"] = putOffset;
    map["token"] = token;
    map["error"] = error;
    map["contextLostReason"] = contextLostReason;
    map["generation"] = generation;
    return map;
  }
}


class _CommandBufferSyncClientDidInitializeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  bool success = false;
  gpu_capabilities_mojom.GpuCapabilities capabilities = null;

  _CommandBufferSyncClientDidInitializeParams() : super(kVersions.last.size);

  _CommandBufferSyncClientDidInitializeParams.init(
    bool this.success, 
    gpu_capabilities_mojom.GpuCapabilities this.capabilities
  ) : super(kVersions.last.size);

  static _CommandBufferSyncClientDidInitializeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferSyncClientDidInitializeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferSyncClientDidInitializeParams result = new _CommandBufferSyncClientDidInitializeParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.success = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.capabilities = gpu_capabilities_mojom.GpuCapabilities.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferSyncClientDidInitializeParams";
    String fieldName;
    try {
      fieldName = "success";
      encoder0.encodeBool(success, 8, 0);
      fieldName = "capabilities";
      encoder0.encodeStruct(capabilities, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferSyncClientDidInitializeParams("
           "success: $success" ", "
           "capabilities: $capabilities" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["success"] = success;
    map["capabilities"] = capabilities;
    return map;
  }
}


class _CommandBufferSyncClientDidMakeProgressParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  CommandBufferState state = null;

  _CommandBufferSyncClientDidMakeProgressParams() : super(kVersions.last.size);

  _CommandBufferSyncClientDidMakeProgressParams.init(
    CommandBufferState this.state
  ) : super(kVersions.last.size);

  static _CommandBufferSyncClientDidMakeProgressParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferSyncClientDidMakeProgressParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferSyncClientDidMakeProgressParams result = new _CommandBufferSyncClientDidMakeProgressParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.state = CommandBufferState.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferSyncClientDidMakeProgressParams";
    String fieldName;
    try {
      fieldName = "state";
      encoder0.encodeStruct(state, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferSyncClientDidMakeProgressParams("
           "state: $state" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["state"] = state;
    return map;
  }
}


class _CommandBufferSyncPointClientDidInsertSyncPointParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int syncPoint = 0;

  _CommandBufferSyncPointClientDidInsertSyncPointParams() : super(kVersions.last.size);

  _CommandBufferSyncPointClientDidInsertSyncPointParams.init(
    int this.syncPoint
  ) : super(kVersions.last.size);

  static _CommandBufferSyncPointClientDidInsertSyncPointParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferSyncPointClientDidInsertSyncPointParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferSyncPointClientDidInsertSyncPointParams result = new _CommandBufferSyncPointClientDidInsertSyncPointParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.syncPoint = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferSyncPointClientDidInsertSyncPointParams";
    String fieldName;
    try {
      fieldName = "syncPoint";
      encoder0.encodeUint32(syncPoint, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferSyncPointClientDidInsertSyncPointParams("
           "syncPoint: $syncPoint" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["syncPoint"] = syncPoint;
    return map;
  }
}


class _CommandBufferLostContextObserverDidLoseContextParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int contextLostReason = 0;

  _CommandBufferLostContextObserverDidLoseContextParams() : super(kVersions.last.size);

  _CommandBufferLostContextObserverDidLoseContextParams.init(
    int this.contextLostReason
  ) : super(kVersions.last.size);

  static _CommandBufferLostContextObserverDidLoseContextParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferLostContextObserverDidLoseContextParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferLostContextObserverDidLoseContextParams result = new _CommandBufferLostContextObserverDidLoseContextParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.contextLostReason = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferLostContextObserverDidLoseContextParams";
    String fieldName;
    try {
      fieldName = "contextLostReason";
      encoder0.encodeInt32(contextLostReason, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferLostContextObserverDidLoseContextParams("
           "contextLostReason: $contextLostReason" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["contextLostReason"] = contextLostReason;
    return map;
  }
}


class _CommandBufferInitializeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  CommandBufferSyncClientInterface syncClient = null;
  CommandBufferSyncPointClientInterface syncPointClient = null;
  CommandBufferLostContextObserverInterface lostObserver = null;
  core.MojoSharedBuffer sharedState = null;

  _CommandBufferInitializeParams() : super(kVersions.last.size);

  _CommandBufferInitializeParams.init(
    CommandBufferSyncClientInterface this.syncClient, 
    CommandBufferSyncPointClientInterface this.syncPointClient, 
    CommandBufferLostContextObserverInterface this.lostObserver, 
    core.MojoSharedBuffer this.sharedState
  ) : super(kVersions.last.size);

  static _CommandBufferInitializeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferInitializeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferInitializeParams result = new _CommandBufferInitializeParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.syncClient = decoder0.decodeServiceInterface(8, false, CommandBufferSyncClientProxy.newFromEndpoint);
    }
    if (mainDataHeader.version >= 0) {
      
      result.syncPointClient = decoder0.decodeServiceInterface(16, false, CommandBufferSyncPointClientProxy.newFromEndpoint);
    }
    if (mainDataHeader.version >= 0) {
      
      result.lostObserver = decoder0.decodeServiceInterface(24, false, CommandBufferLostContextObserverProxy.newFromEndpoint);
    }
    if (mainDataHeader.version >= 0) {
      
      result.sharedState = decoder0.decodeSharedBufferHandle(32, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferInitializeParams";
    String fieldName;
    try {
      fieldName = "syncClient";
      encoder0.encodeInterface(syncClient, 8, false);
      fieldName = "syncPointClient";
      encoder0.encodeInterface(syncPointClient, 16, false);
      fieldName = "lostObserver";
      encoder0.encodeInterface(lostObserver, 24, false);
      fieldName = "sharedState";
      encoder0.encodeSharedBufferHandle(sharedState, 32, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferInitializeParams("
           "syncClient: $syncClient" ", "
           "syncPointClient: $syncPointClient" ", "
           "lostObserver: $lostObserver" ", "
           "sharedState: $sharedState" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _CommandBufferSetGetBufferParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int buffer = 0;

  _CommandBufferSetGetBufferParams() : super(kVersions.last.size);

  _CommandBufferSetGetBufferParams.init(
    int this.buffer
  ) : super(kVersions.last.size);

  static _CommandBufferSetGetBufferParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferSetGetBufferParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferSetGetBufferParams result = new _CommandBufferSetGetBufferParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.buffer = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferSetGetBufferParams";
    String fieldName;
    try {
      fieldName = "buffer";
      encoder0.encodeInt32(buffer, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferSetGetBufferParams("
           "buffer: $buffer" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["buffer"] = buffer;
    return map;
  }
}


class _CommandBufferFlushParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int putOffset = 0;

  _CommandBufferFlushParams() : super(kVersions.last.size);

  _CommandBufferFlushParams.init(
    int this.putOffset
  ) : super(kVersions.last.size);

  static _CommandBufferFlushParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferFlushParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferFlushParams result = new _CommandBufferFlushParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.putOffset = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferFlushParams";
    String fieldName;
    try {
      fieldName = "putOffset";
      encoder0.encodeInt32(putOffset, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferFlushParams("
           "putOffset: $putOffset" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["putOffset"] = putOffset;
    return map;
  }
}


class _CommandBufferMakeProgressParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int lastGetOffset = 0;

  _CommandBufferMakeProgressParams() : super(kVersions.last.size);

  _CommandBufferMakeProgressParams.init(
    int this.lastGetOffset
  ) : super(kVersions.last.size);

  static _CommandBufferMakeProgressParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferMakeProgressParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferMakeProgressParams result = new _CommandBufferMakeProgressParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.lastGetOffset = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferMakeProgressParams";
    String fieldName;
    try {
      fieldName = "lastGetOffset";
      encoder0.encodeInt32(lastGetOffset, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferMakeProgressParams("
           "lastGetOffset: $lastGetOffset" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["lastGetOffset"] = lastGetOffset;
    return map;
  }
}


class _CommandBufferRegisterTransferBufferParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int id = 0;
  core.MojoSharedBuffer transferBuffer = null;
  int size = 0;

  _CommandBufferRegisterTransferBufferParams() : super(kVersions.last.size);

  _CommandBufferRegisterTransferBufferParams.init(
    int this.id, 
    core.MojoSharedBuffer this.transferBuffer, 
    int this.size
  ) : super(kVersions.last.size);

  static _CommandBufferRegisterTransferBufferParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferRegisterTransferBufferParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferRegisterTransferBufferParams result = new _CommandBufferRegisterTransferBufferParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.transferBuffer = decoder0.decodeSharedBufferHandle(12, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.size = decoder0.decodeUint32(16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferRegisterTransferBufferParams";
    String fieldName;
    try {
      fieldName = "id";
      encoder0.encodeInt32(id, 8);
      fieldName = "transferBuffer";
      encoder0.encodeSharedBufferHandle(transferBuffer, 12, false);
      fieldName = "size";
      encoder0.encodeUint32(size, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferRegisterTransferBufferParams("
           "id: $id" ", "
           "transferBuffer: $transferBuffer" ", "
           "size: $size" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _CommandBufferDestroyTransferBufferParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int id = 0;

  _CommandBufferDestroyTransferBufferParams() : super(kVersions.last.size);

  _CommandBufferDestroyTransferBufferParams.init(
    int this.id
  ) : super(kVersions.last.size);

  static _CommandBufferDestroyTransferBufferParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferDestroyTransferBufferParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferDestroyTransferBufferParams result = new _CommandBufferDestroyTransferBufferParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferDestroyTransferBufferParams";
    String fieldName;
    try {
      fieldName = "id";
      encoder0.encodeInt32(id, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferDestroyTransferBufferParams("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class _CommandBufferInsertSyncPointParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool retire = false;

  _CommandBufferInsertSyncPointParams() : super(kVersions.last.size);

  _CommandBufferInsertSyncPointParams.init(
    bool this.retire
  ) : super(kVersions.last.size);

  static _CommandBufferInsertSyncPointParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferInsertSyncPointParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferInsertSyncPointParams result = new _CommandBufferInsertSyncPointParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.retire = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferInsertSyncPointParams";
    String fieldName;
    try {
      fieldName = "retire";
      encoder0.encodeBool(retire, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferInsertSyncPointParams("
           "retire: $retire" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["retire"] = retire;
    return map;
  }
}


class _CommandBufferRetireSyncPointParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int syncPoint = 0;

  _CommandBufferRetireSyncPointParams() : super(kVersions.last.size);

  _CommandBufferRetireSyncPointParams.init(
    int this.syncPoint
  ) : super(kVersions.last.size);

  static _CommandBufferRetireSyncPointParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferRetireSyncPointParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferRetireSyncPointParams result = new _CommandBufferRetireSyncPointParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.syncPoint = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferRetireSyncPointParams";
    String fieldName;
    try {
      fieldName = "syncPoint";
      encoder0.encodeUint32(syncPoint, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferRetireSyncPointParams("
           "syncPoint: $syncPoint" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["syncPoint"] = syncPoint;
    return map;
  }
}


class _CommandBufferEchoParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CommandBufferEchoParams() : super(kVersions.last.size);

  _CommandBufferEchoParams.init(
  ) : super(kVersions.last.size);

  static _CommandBufferEchoParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CommandBufferEchoParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CommandBufferEchoParams result = new _CommandBufferEchoParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CommandBufferEchoParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CommandBufferEchoParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class CommandBufferEchoResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CommandBufferEchoResponseParams() : super(kVersions.last.size);

  CommandBufferEchoResponseParams.init(
  ) : super(kVersions.last.size);

  static CommandBufferEchoResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CommandBufferEchoResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CommandBufferEchoResponseParams result = new CommandBufferEchoResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CommandBufferEchoResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CommandBufferEchoResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}

const int _commandBufferSyncClientMethodDidInitializeName = 0;
const int _commandBufferSyncClientMethodDidMakeProgressName = 1;

class _CommandBufferSyncClientServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CommandBufferSyncClient {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CommandBufferSyncClientServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CommandBufferSyncClientProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CommandBufferSyncClientProxy p = new CommandBufferSyncClientProxy.unbound();
    String name = serviceName ?? CommandBufferSyncClient.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void didInitialize(bool success, gpu_capabilities_mojom.GpuCapabilities capabilities);
  void didMakeProgress(CommandBufferState state);
}

abstract class CommandBufferSyncClientInterface
    implements bindings.MojoInterface<CommandBufferSyncClient>,
               CommandBufferSyncClient {
  factory CommandBufferSyncClientInterface([CommandBufferSyncClient impl]) =>
      new CommandBufferSyncClientStub.unbound(impl);

  factory CommandBufferSyncClientInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CommandBufferSyncClient impl]) =>
      new CommandBufferSyncClientStub.fromEndpoint(endpoint, impl);

  factory CommandBufferSyncClientInterface.fromMock(
      CommandBufferSyncClient mock) =>
      new CommandBufferSyncClientProxy.fromMock(mock);
}

abstract class CommandBufferSyncClientInterfaceRequest
    implements bindings.MojoInterface<CommandBufferSyncClient>,
               CommandBufferSyncClient {
  factory CommandBufferSyncClientInterfaceRequest() =>
      new CommandBufferSyncClientProxy.unbound();
}

class _CommandBufferSyncClientProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CommandBufferSyncClient> {
  CommandBufferSyncClient impl;

  _CommandBufferSyncClientProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CommandBufferSyncClientProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CommandBufferSyncClientProxyControl.unbound() : super.unbound();

  String get serviceName => CommandBufferSyncClient.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferSyncClientProxyControl($superString)";
  }
}

class CommandBufferSyncClientProxy
    extends bindings.Proxy<CommandBufferSyncClient>
    implements CommandBufferSyncClient,
               CommandBufferSyncClientInterface,
               CommandBufferSyncClientInterfaceRequest {
  CommandBufferSyncClientProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CommandBufferSyncClientProxyControl.fromEndpoint(endpoint));

  CommandBufferSyncClientProxy.fromHandle(core.MojoHandle handle)
      : super(new _CommandBufferSyncClientProxyControl.fromHandle(handle));

  CommandBufferSyncClientProxy.unbound()
      : super(new _CommandBufferSyncClientProxyControl.unbound());

  factory CommandBufferSyncClientProxy.fromMock(CommandBufferSyncClient mock) {
    CommandBufferSyncClientProxy newMockedProxy =
        new CommandBufferSyncClientProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CommandBufferSyncClientProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferSyncClientProxy"));
    return new CommandBufferSyncClientProxy.fromEndpoint(endpoint);
  }


  void didInitialize(bool success, gpu_capabilities_mojom.GpuCapabilities capabilities) {
    if (impl != null) {
      impl.didInitialize(success, capabilities);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferSyncClientDidInitializeParams();
    params.success = success;
    params.capabilities = capabilities;
    ctrl.sendMessage(params,
        _commandBufferSyncClientMethodDidInitializeName);
  }
  void didMakeProgress(CommandBufferState state) {
    if (impl != null) {
      impl.didMakeProgress(state);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferSyncClientDidMakeProgressParams();
    params.state = state;
    ctrl.sendMessage(params,
        _commandBufferSyncClientMethodDidMakeProgressName);
  }
}

class _CommandBufferSyncClientStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CommandBufferSyncClient> {
  CommandBufferSyncClient _impl;

  _CommandBufferSyncClientStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBufferSyncClient impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferSyncClientStubControl.fromHandle(
      core.MojoHandle handle, [CommandBufferSyncClient impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferSyncClientStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CommandBufferSyncClient.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _commandBufferSyncClientMethodDidInitializeName:
        var params = _CommandBufferSyncClientDidInitializeParams.deserialize(
            message.payload);
        _impl.didInitialize(params.success, params.capabilities);
        break;
      case _commandBufferSyncClientMethodDidMakeProgressName:
        var params = _CommandBufferSyncClientDidMakeProgressParams.deserialize(
            message.payload);
        _impl.didMakeProgress(params.state);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CommandBufferSyncClient get impl => _impl;
  set impl(CommandBufferSyncClient d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferSyncClientStubControl($superString)";
  }

  int get version => 0;
}

class CommandBufferSyncClientStub
    extends bindings.Stub<CommandBufferSyncClient>
    implements CommandBufferSyncClient,
               CommandBufferSyncClientInterface,
               CommandBufferSyncClientInterfaceRequest {
  CommandBufferSyncClientStub.unbound([CommandBufferSyncClient impl])
      : super(new _CommandBufferSyncClientStubControl.unbound(impl));

  CommandBufferSyncClientStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBufferSyncClient impl])
      : super(new _CommandBufferSyncClientStubControl.fromEndpoint(endpoint, impl));

  CommandBufferSyncClientStub.fromHandle(
      core.MojoHandle handle, [CommandBufferSyncClient impl])
      : super(new _CommandBufferSyncClientStubControl.fromHandle(handle, impl));

  static CommandBufferSyncClientStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferSyncClientStub"));
    return new CommandBufferSyncClientStub.fromEndpoint(endpoint);
  }


  void didInitialize(bool success, gpu_capabilities_mojom.GpuCapabilities capabilities) {
    return impl.didInitialize(success, capabilities);
  }
  void didMakeProgress(CommandBufferState state) {
    return impl.didMakeProgress(state);
  }
}

const int _commandBufferSyncPointClientMethodDidInsertSyncPointName = 0;

class _CommandBufferSyncPointClientServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CommandBufferSyncPointClient {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CommandBufferSyncPointClientServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CommandBufferSyncPointClientProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CommandBufferSyncPointClientProxy p = new CommandBufferSyncPointClientProxy.unbound();
    String name = serviceName ?? CommandBufferSyncPointClient.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void didInsertSyncPoint(int syncPoint);
}

abstract class CommandBufferSyncPointClientInterface
    implements bindings.MojoInterface<CommandBufferSyncPointClient>,
               CommandBufferSyncPointClient {
  factory CommandBufferSyncPointClientInterface([CommandBufferSyncPointClient impl]) =>
      new CommandBufferSyncPointClientStub.unbound(impl);

  factory CommandBufferSyncPointClientInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CommandBufferSyncPointClient impl]) =>
      new CommandBufferSyncPointClientStub.fromEndpoint(endpoint, impl);

  factory CommandBufferSyncPointClientInterface.fromMock(
      CommandBufferSyncPointClient mock) =>
      new CommandBufferSyncPointClientProxy.fromMock(mock);
}

abstract class CommandBufferSyncPointClientInterfaceRequest
    implements bindings.MojoInterface<CommandBufferSyncPointClient>,
               CommandBufferSyncPointClient {
  factory CommandBufferSyncPointClientInterfaceRequest() =>
      new CommandBufferSyncPointClientProxy.unbound();
}

class _CommandBufferSyncPointClientProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CommandBufferSyncPointClient> {
  CommandBufferSyncPointClient impl;

  _CommandBufferSyncPointClientProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CommandBufferSyncPointClientProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CommandBufferSyncPointClientProxyControl.unbound() : super.unbound();

  String get serviceName => CommandBufferSyncPointClient.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferSyncPointClientProxyControl($superString)";
  }
}

class CommandBufferSyncPointClientProxy
    extends bindings.Proxy<CommandBufferSyncPointClient>
    implements CommandBufferSyncPointClient,
               CommandBufferSyncPointClientInterface,
               CommandBufferSyncPointClientInterfaceRequest {
  CommandBufferSyncPointClientProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CommandBufferSyncPointClientProxyControl.fromEndpoint(endpoint));

  CommandBufferSyncPointClientProxy.fromHandle(core.MojoHandle handle)
      : super(new _CommandBufferSyncPointClientProxyControl.fromHandle(handle));

  CommandBufferSyncPointClientProxy.unbound()
      : super(new _CommandBufferSyncPointClientProxyControl.unbound());

  factory CommandBufferSyncPointClientProxy.fromMock(CommandBufferSyncPointClient mock) {
    CommandBufferSyncPointClientProxy newMockedProxy =
        new CommandBufferSyncPointClientProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CommandBufferSyncPointClientProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferSyncPointClientProxy"));
    return new CommandBufferSyncPointClientProxy.fromEndpoint(endpoint);
  }


  void didInsertSyncPoint(int syncPoint) {
    if (impl != null) {
      impl.didInsertSyncPoint(syncPoint);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferSyncPointClientDidInsertSyncPointParams();
    params.syncPoint = syncPoint;
    ctrl.sendMessage(params,
        _commandBufferSyncPointClientMethodDidInsertSyncPointName);
  }
}

class _CommandBufferSyncPointClientStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CommandBufferSyncPointClient> {
  CommandBufferSyncPointClient _impl;

  _CommandBufferSyncPointClientStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBufferSyncPointClient impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferSyncPointClientStubControl.fromHandle(
      core.MojoHandle handle, [CommandBufferSyncPointClient impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferSyncPointClientStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CommandBufferSyncPointClient.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _commandBufferSyncPointClientMethodDidInsertSyncPointName:
        var params = _CommandBufferSyncPointClientDidInsertSyncPointParams.deserialize(
            message.payload);
        _impl.didInsertSyncPoint(params.syncPoint);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CommandBufferSyncPointClient get impl => _impl;
  set impl(CommandBufferSyncPointClient d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferSyncPointClientStubControl($superString)";
  }

  int get version => 0;
}

class CommandBufferSyncPointClientStub
    extends bindings.Stub<CommandBufferSyncPointClient>
    implements CommandBufferSyncPointClient,
               CommandBufferSyncPointClientInterface,
               CommandBufferSyncPointClientInterfaceRequest {
  CommandBufferSyncPointClientStub.unbound([CommandBufferSyncPointClient impl])
      : super(new _CommandBufferSyncPointClientStubControl.unbound(impl));

  CommandBufferSyncPointClientStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBufferSyncPointClient impl])
      : super(new _CommandBufferSyncPointClientStubControl.fromEndpoint(endpoint, impl));

  CommandBufferSyncPointClientStub.fromHandle(
      core.MojoHandle handle, [CommandBufferSyncPointClient impl])
      : super(new _CommandBufferSyncPointClientStubControl.fromHandle(handle, impl));

  static CommandBufferSyncPointClientStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferSyncPointClientStub"));
    return new CommandBufferSyncPointClientStub.fromEndpoint(endpoint);
  }


  void didInsertSyncPoint(int syncPoint) {
    return impl.didInsertSyncPoint(syncPoint);
  }
}

const int _commandBufferLostContextObserverMethodDidLoseContextName = 0;

class _CommandBufferLostContextObserverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CommandBufferLostContextObserver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CommandBufferLostContextObserverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CommandBufferLostContextObserverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CommandBufferLostContextObserverProxy p = new CommandBufferLostContextObserverProxy.unbound();
    String name = serviceName ?? CommandBufferLostContextObserver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void didLoseContext(int contextLostReason);
}

abstract class CommandBufferLostContextObserverInterface
    implements bindings.MojoInterface<CommandBufferLostContextObserver>,
               CommandBufferLostContextObserver {
  factory CommandBufferLostContextObserverInterface([CommandBufferLostContextObserver impl]) =>
      new CommandBufferLostContextObserverStub.unbound(impl);

  factory CommandBufferLostContextObserverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CommandBufferLostContextObserver impl]) =>
      new CommandBufferLostContextObserverStub.fromEndpoint(endpoint, impl);

  factory CommandBufferLostContextObserverInterface.fromMock(
      CommandBufferLostContextObserver mock) =>
      new CommandBufferLostContextObserverProxy.fromMock(mock);
}

abstract class CommandBufferLostContextObserverInterfaceRequest
    implements bindings.MojoInterface<CommandBufferLostContextObserver>,
               CommandBufferLostContextObserver {
  factory CommandBufferLostContextObserverInterfaceRequest() =>
      new CommandBufferLostContextObserverProxy.unbound();
}

class _CommandBufferLostContextObserverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CommandBufferLostContextObserver> {
  CommandBufferLostContextObserver impl;

  _CommandBufferLostContextObserverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CommandBufferLostContextObserverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CommandBufferLostContextObserverProxyControl.unbound() : super.unbound();

  String get serviceName => CommandBufferLostContextObserver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferLostContextObserverProxyControl($superString)";
  }
}

class CommandBufferLostContextObserverProxy
    extends bindings.Proxy<CommandBufferLostContextObserver>
    implements CommandBufferLostContextObserver,
               CommandBufferLostContextObserverInterface,
               CommandBufferLostContextObserverInterfaceRequest {
  CommandBufferLostContextObserverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CommandBufferLostContextObserverProxyControl.fromEndpoint(endpoint));

  CommandBufferLostContextObserverProxy.fromHandle(core.MojoHandle handle)
      : super(new _CommandBufferLostContextObserverProxyControl.fromHandle(handle));

  CommandBufferLostContextObserverProxy.unbound()
      : super(new _CommandBufferLostContextObserverProxyControl.unbound());

  factory CommandBufferLostContextObserverProxy.fromMock(CommandBufferLostContextObserver mock) {
    CommandBufferLostContextObserverProxy newMockedProxy =
        new CommandBufferLostContextObserverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CommandBufferLostContextObserverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferLostContextObserverProxy"));
    return new CommandBufferLostContextObserverProxy.fromEndpoint(endpoint);
  }


  void didLoseContext(int contextLostReason) {
    if (impl != null) {
      impl.didLoseContext(contextLostReason);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferLostContextObserverDidLoseContextParams();
    params.contextLostReason = contextLostReason;
    ctrl.sendMessage(params,
        _commandBufferLostContextObserverMethodDidLoseContextName);
  }
}

class _CommandBufferLostContextObserverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CommandBufferLostContextObserver> {
  CommandBufferLostContextObserver _impl;

  _CommandBufferLostContextObserverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBufferLostContextObserver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferLostContextObserverStubControl.fromHandle(
      core.MojoHandle handle, [CommandBufferLostContextObserver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferLostContextObserverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CommandBufferLostContextObserver.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _commandBufferLostContextObserverMethodDidLoseContextName:
        var params = _CommandBufferLostContextObserverDidLoseContextParams.deserialize(
            message.payload);
        _impl.didLoseContext(params.contextLostReason);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CommandBufferLostContextObserver get impl => _impl;
  set impl(CommandBufferLostContextObserver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferLostContextObserverStubControl($superString)";
  }

  int get version => 0;
}

class CommandBufferLostContextObserverStub
    extends bindings.Stub<CommandBufferLostContextObserver>
    implements CommandBufferLostContextObserver,
               CommandBufferLostContextObserverInterface,
               CommandBufferLostContextObserverInterfaceRequest {
  CommandBufferLostContextObserverStub.unbound([CommandBufferLostContextObserver impl])
      : super(new _CommandBufferLostContextObserverStubControl.unbound(impl));

  CommandBufferLostContextObserverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBufferLostContextObserver impl])
      : super(new _CommandBufferLostContextObserverStubControl.fromEndpoint(endpoint, impl));

  CommandBufferLostContextObserverStub.fromHandle(
      core.MojoHandle handle, [CommandBufferLostContextObserver impl])
      : super(new _CommandBufferLostContextObserverStubControl.fromHandle(handle, impl));

  static CommandBufferLostContextObserverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferLostContextObserverStub"));
    return new CommandBufferLostContextObserverStub.fromEndpoint(endpoint);
  }


  void didLoseContext(int contextLostReason) {
    return impl.didLoseContext(contextLostReason);
  }
}

const int _commandBufferMethodInitializeName = 0;
const int _commandBufferMethodSetGetBufferName = 1;
const int _commandBufferMethodFlushName = 2;
const int _commandBufferMethodMakeProgressName = 3;
const int _commandBufferMethodRegisterTransferBufferName = 4;
const int _commandBufferMethodDestroyTransferBufferName = 5;
const int _commandBufferMethodInsertSyncPointName = 6;
const int _commandBufferMethodRetireSyncPointName = 7;
const int _commandBufferMethodEchoName = 8;

class _CommandBufferServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CommandBuffer {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CommandBufferServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CommandBufferProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CommandBufferProxy p = new CommandBufferProxy.unbound();
    String name = serviceName ?? CommandBuffer.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void initialize(CommandBufferSyncClientInterface syncClient, CommandBufferSyncPointClientInterface syncPointClient, CommandBufferLostContextObserverInterface lostObserver, core.MojoSharedBuffer sharedState);
  void setGetBuffer(int buffer);
  void flush(int putOffset);
  void makeProgress(int lastGetOffset);
  void registerTransferBuffer(int id, core.MojoSharedBuffer transferBuffer, int size);
  void destroyTransferBuffer(int id);
  void insertSyncPoint(bool retire);
  void retireSyncPoint(int syncPoint);
  void echo(void callback());
}

abstract class CommandBufferInterface
    implements bindings.MojoInterface<CommandBuffer>,
               CommandBuffer {
  factory CommandBufferInterface([CommandBuffer impl]) =>
      new CommandBufferStub.unbound(impl);

  factory CommandBufferInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CommandBuffer impl]) =>
      new CommandBufferStub.fromEndpoint(endpoint, impl);

  factory CommandBufferInterface.fromMock(
      CommandBuffer mock) =>
      new CommandBufferProxy.fromMock(mock);
}

abstract class CommandBufferInterfaceRequest
    implements bindings.MojoInterface<CommandBuffer>,
               CommandBuffer {
  factory CommandBufferInterfaceRequest() =>
      new CommandBufferProxy.unbound();
}

class _CommandBufferProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CommandBuffer> {
  CommandBuffer impl;

  _CommandBufferProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CommandBufferProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CommandBufferProxyControl.unbound() : super.unbound();

  String get serviceName => CommandBuffer.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _commandBufferMethodEchoName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CommandBufferEchoResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferProxyControl($superString)";
  }
}

class CommandBufferProxy
    extends bindings.Proxy<CommandBuffer>
    implements CommandBuffer,
               CommandBufferInterface,
               CommandBufferInterfaceRequest {
  CommandBufferProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CommandBufferProxyControl.fromEndpoint(endpoint));

  CommandBufferProxy.fromHandle(core.MojoHandle handle)
      : super(new _CommandBufferProxyControl.fromHandle(handle));

  CommandBufferProxy.unbound()
      : super(new _CommandBufferProxyControl.unbound());

  factory CommandBufferProxy.fromMock(CommandBuffer mock) {
    CommandBufferProxy newMockedProxy =
        new CommandBufferProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CommandBufferProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferProxy"));
    return new CommandBufferProxy.fromEndpoint(endpoint);
  }


  void initialize(CommandBufferSyncClientInterface syncClient, CommandBufferSyncPointClientInterface syncPointClient, CommandBufferLostContextObserverInterface lostObserver, core.MojoSharedBuffer sharedState) {
    if (impl != null) {
      impl.initialize(syncClient, syncPointClient, lostObserver, sharedState);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferInitializeParams();
    params.syncClient = syncClient;
    params.syncPointClient = syncPointClient;
    params.lostObserver = lostObserver;
    params.sharedState = sharedState;
    ctrl.sendMessage(params,
        _commandBufferMethodInitializeName);
  }
  void setGetBuffer(int buffer) {
    if (impl != null) {
      impl.setGetBuffer(buffer);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferSetGetBufferParams();
    params.buffer = buffer;
    ctrl.sendMessage(params,
        _commandBufferMethodSetGetBufferName);
  }
  void flush(int putOffset) {
    if (impl != null) {
      impl.flush(putOffset);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferFlushParams();
    params.putOffset = putOffset;
    ctrl.sendMessage(params,
        _commandBufferMethodFlushName);
  }
  void makeProgress(int lastGetOffset) {
    if (impl != null) {
      impl.makeProgress(lastGetOffset);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferMakeProgressParams();
    params.lastGetOffset = lastGetOffset;
    ctrl.sendMessage(params,
        _commandBufferMethodMakeProgressName);
  }
  void registerTransferBuffer(int id, core.MojoSharedBuffer transferBuffer, int size) {
    if (impl != null) {
      impl.registerTransferBuffer(id, transferBuffer, size);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferRegisterTransferBufferParams();
    params.id = id;
    params.transferBuffer = transferBuffer;
    params.size = size;
    ctrl.sendMessage(params,
        _commandBufferMethodRegisterTransferBufferName);
  }
  void destroyTransferBuffer(int id) {
    if (impl != null) {
      impl.destroyTransferBuffer(id);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferDestroyTransferBufferParams();
    params.id = id;
    ctrl.sendMessage(params,
        _commandBufferMethodDestroyTransferBufferName);
  }
  void insertSyncPoint(bool retire) {
    if (impl != null) {
      impl.insertSyncPoint(retire);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferInsertSyncPointParams();
    params.retire = retire;
    ctrl.sendMessage(params,
        _commandBufferMethodInsertSyncPointName);
  }
  void retireSyncPoint(int syncPoint) {
    if (impl != null) {
      impl.retireSyncPoint(syncPoint);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CommandBufferRetireSyncPointParams();
    params.syncPoint = syncPoint;
    ctrl.sendMessage(params,
        _commandBufferMethodRetireSyncPointName);
  }
  void echo(void callback()) {
    if (impl != null) {
      impl.echo(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CommandBufferEchoParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _commandBufferMethodEchoName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CommandBufferStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CommandBuffer> {
  CommandBuffer _impl;

  _CommandBufferStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBuffer impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferStubControl.fromHandle(
      core.MojoHandle handle, [CommandBuffer impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CommandBufferStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CommandBuffer.serviceName;


  Function _commandBufferEchoResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CommandBufferEchoResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _commandBufferMethodEchoName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _commandBufferMethodInitializeName:
        var params = _CommandBufferInitializeParams.deserialize(
            message.payload);
        _impl.initialize(params.syncClient, params.syncPointClient, params.lostObserver, params.sharedState);
        break;
      case _commandBufferMethodSetGetBufferName:
        var params = _CommandBufferSetGetBufferParams.deserialize(
            message.payload);
        _impl.setGetBuffer(params.buffer);
        break;
      case _commandBufferMethodFlushName:
        var params = _CommandBufferFlushParams.deserialize(
            message.payload);
        _impl.flush(params.putOffset);
        break;
      case _commandBufferMethodMakeProgressName:
        var params = _CommandBufferMakeProgressParams.deserialize(
            message.payload);
        _impl.makeProgress(params.lastGetOffset);
        break;
      case _commandBufferMethodRegisterTransferBufferName:
        var params = _CommandBufferRegisterTransferBufferParams.deserialize(
            message.payload);
        _impl.registerTransferBuffer(params.id, params.transferBuffer, params.size);
        break;
      case _commandBufferMethodDestroyTransferBufferName:
        var params = _CommandBufferDestroyTransferBufferParams.deserialize(
            message.payload);
        _impl.destroyTransferBuffer(params.id);
        break;
      case _commandBufferMethodInsertSyncPointName:
        var params = _CommandBufferInsertSyncPointParams.deserialize(
            message.payload);
        _impl.insertSyncPoint(params.retire);
        break;
      case _commandBufferMethodRetireSyncPointName:
        var params = _CommandBufferRetireSyncPointParams.deserialize(
            message.payload);
        _impl.retireSyncPoint(params.syncPoint);
        break;
      case _commandBufferMethodEchoName:
        _impl.echo(_commandBufferEchoResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CommandBuffer get impl => _impl;
  set impl(CommandBuffer d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CommandBufferStubControl($superString)";
  }

  int get version => 0;
}

class CommandBufferStub
    extends bindings.Stub<CommandBuffer>
    implements CommandBuffer,
               CommandBufferInterface,
               CommandBufferInterfaceRequest {
  CommandBufferStub.unbound([CommandBuffer impl])
      : super(new _CommandBufferStubControl.unbound(impl));

  CommandBufferStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CommandBuffer impl])
      : super(new _CommandBufferStubControl.fromEndpoint(endpoint, impl));

  CommandBufferStub.fromHandle(
      core.MojoHandle handle, [CommandBuffer impl])
      : super(new _CommandBufferStubControl.fromHandle(handle, impl));

  static CommandBufferStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CommandBufferStub"));
    return new CommandBufferStub.fromEndpoint(endpoint);
  }


  void initialize(CommandBufferSyncClientInterface syncClient, CommandBufferSyncPointClientInterface syncPointClient, CommandBufferLostContextObserverInterface lostObserver, core.MojoSharedBuffer sharedState) {
    return impl.initialize(syncClient, syncPointClient, lostObserver, sharedState);
  }
  void setGetBuffer(int buffer) {
    return impl.setGetBuffer(buffer);
  }
  void flush(int putOffset) {
    return impl.flush(putOffset);
  }
  void makeProgress(int lastGetOffset) {
    return impl.makeProgress(lastGetOffset);
  }
  void registerTransferBuffer(int id, core.MojoSharedBuffer transferBuffer, int size) {
    return impl.registerTransferBuffer(id, transferBuffer, size);
  }
  void destroyTransferBuffer(int id) {
    return impl.destroyTransferBuffer(id);
  }
  void insertSyncPoint(bool retire) {
    return impl.insertSyncPoint(retire);
  }
  void retireSyncPoint(int syncPoint) {
    return impl.retireSyncPoint(syncPoint);
  }
  void echo(void callback()) {
    return impl.echo(callback);
  }
}



