// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library dart_to_cpp_mojom;
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class EchoArgs extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(104, 0)
  ];
  int si64 = 0;
  int si32 = 0;
  int si16 = 0;
  int si8 = 0;
  int ui8 = 0;
  int ui64 = 0;
  int ui32 = 0;
  int ui16 = 0;
  double floatVal = 0.0;
  double floatInf = 0.0;
  double floatNan = 0.0;
  core.MojoMessagePipeEndpoint messageHandle = null;
  double doubleVal = 0.0;
  double doubleInf = 0.0;
  double doubleNan = 0.0;
  String name = null;
  List<String> stringArray = null;
  core.MojoDataPipeConsumer dataHandle = null;

  EchoArgs() : super(kVersions.last.size);

  EchoArgs.init(
    int this.si64, 
    int this.si32, 
    int this.si16, 
    int this.si8, 
    int this.ui8, 
    int this.ui64, 
    int this.ui32, 
    int this.ui16, 
    double this.floatVal, 
    double this.floatInf, 
    double this.floatNan, 
    core.MojoMessagePipeEndpoint this.messageHandle, 
    double this.doubleVal, 
    double this.doubleInf, 
    double this.doubleNan, 
    String this.name, 
    List<String> this.stringArray, 
    core.MojoDataPipeConsumer this.dataHandle
  ) : super(kVersions.last.size);

  static EchoArgs deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EchoArgs decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EchoArgs result = new EchoArgs();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.si64 = decoder0.decodeInt64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.si32 = decoder0.decodeInt32(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.si16 = decoder0.decodeInt16(20);
    }
    if (mainDataHeader.version >= 0) {
      
      result.si8 = decoder0.decodeInt8(22);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui8 = decoder0.decodeUint8(23);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui64 = decoder0.decodeUint64(24);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui32 = decoder0.decodeUint32(32);
    }
    if (mainDataHeader.version >= 0) {
      
      result.ui16 = decoder0.decodeUint16(36);
    }
    if (mainDataHeader.version >= 0) {
      
      result.floatVal = decoder0.decodeFloat(40);
    }
    if (mainDataHeader.version >= 0) {
      
      result.floatInf = decoder0.decodeFloat(44);
    }
    if (mainDataHeader.version >= 0) {
      
      result.floatNan = decoder0.decodeFloat(48);
    }
    if (mainDataHeader.version >= 0) {
      
      result.messageHandle = decoder0.decodeMessagePipeHandle(52, true);
    }
    if (mainDataHeader.version >= 0) {
      
      result.doubleVal = decoder0.decodeDouble(56);
    }
    if (mainDataHeader.version >= 0) {
      
      result.doubleInf = decoder0.decodeDouble(64);
    }
    if (mainDataHeader.version >= 0) {
      
      result.doubleNan = decoder0.decodeDouble(72);
    }
    if (mainDataHeader.version >= 0) {
      
      result.name = decoder0.decodeString(80, true);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(88, true);
      if (decoder1 == null) {
        result.stringArray = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.stringArray = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.stringArray[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      result.dataHandle = decoder0.decodeConsumerHandle(96, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EchoArgs";
    String fieldName;
    try {
      fieldName = "si64";
      encoder0.encodeInt64(si64, 8);
      fieldName = "si32";
      encoder0.encodeInt32(si32, 16);
      fieldName = "si16";
      encoder0.encodeInt16(si16, 20);
      fieldName = "si8";
      encoder0.encodeInt8(si8, 22);
      fieldName = "ui8";
      encoder0.encodeUint8(ui8, 23);
      fieldName = "ui64";
      encoder0.encodeUint64(ui64, 24);
      fieldName = "ui32";
      encoder0.encodeUint32(ui32, 32);
      fieldName = "ui16";
      encoder0.encodeUint16(ui16, 36);
      fieldName = "floatVal";
      encoder0.encodeFloat(floatVal, 40);
      fieldName = "floatInf";
      encoder0.encodeFloat(floatInf, 44);
      fieldName = "floatNan";
      encoder0.encodeFloat(floatNan, 48);
      fieldName = "messageHandle";
      encoder0.encodeMessagePipeHandle(messageHandle, 52, true);
      fieldName = "doubleVal";
      encoder0.encodeDouble(doubleVal, 56);
      fieldName = "doubleInf";
      encoder0.encodeDouble(doubleInf, 64);
      fieldName = "doubleNan";
      encoder0.encodeDouble(doubleNan, 72);
      fieldName = "name";
      encoder0.encodeString(name, 80, true);
      fieldName = "stringArray";
      if (stringArray == null) {
        encoder0.encodeNullPointer(88, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(stringArray.length, 88, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < stringArray.length; ++i0) {
          encoder1.encodeString(stringArray[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
      fieldName = "dataHandle";
      encoder0.encodeConsumerHandle(dataHandle, 96, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EchoArgs("
           "si64: $si64" ", "
           "si32: $si32" ", "
           "si16: $si16" ", "
           "si8: $si8" ", "
           "ui8: $ui8" ", "
           "ui64: $ui64" ", "
           "ui32: $ui32" ", "
           "ui16: $ui16" ", "
           "floatVal: $floatVal" ", "
           "floatInf: $floatInf" ", "
           "floatNan: $floatNan" ", "
           "messageHandle: $messageHandle" ", "
           "doubleVal: $doubleVal" ", "
           "doubleInf: $doubleInf" ", "
           "doubleNan: $doubleNan" ", "
           "name: $name" ", "
           "stringArray: $stringArray" ", "
           "dataHandle: $dataHandle" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class EchoArgsList extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  EchoArgsList next = null;
  EchoArgs item = null;

  EchoArgsList() : super(kVersions.last.size);

  EchoArgsList.init(
    EchoArgsList this.next, 
    EchoArgs this.item
  ) : super(kVersions.last.size);

  static EchoArgsList deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EchoArgsList decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EchoArgsList result = new EchoArgsList();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.next = EchoArgsList.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.item = EchoArgs.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EchoArgsList";
    String fieldName;
    try {
      fieldName = "next";
      encoder0.encodeStruct(next, 8, true);
      fieldName = "item";
      encoder0.encodeStruct(item, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EchoArgsList("
           "next: $next" ", "
           "item: $item" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _CppSideStartTestParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CppSideStartTestParams() : super(kVersions.last.size);

  _CppSideStartTestParams.init(
  ) : super(kVersions.last.size);

  static _CppSideStartTestParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideStartTestParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideStartTestParams result = new _CppSideStartTestParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideStartTestParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideStartTestParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CppSideTestFinishedParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CppSideTestFinishedParams() : super(kVersions.last.size);

  _CppSideTestFinishedParams.init(
  ) : super(kVersions.last.size);

  static _CppSideTestFinishedParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideTestFinishedParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideTestFinishedParams result = new _CppSideTestFinishedParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideTestFinishedParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideTestFinishedParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CppSidePingResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CppSidePingResponseParams() : super(kVersions.last.size);

  _CppSidePingResponseParams.init(
  ) : super(kVersions.last.size);

  static _CppSidePingResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSidePingResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSidePingResponseParams result = new _CppSidePingResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSidePingResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSidePingResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CppSideEchoResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EchoArgsList list = null;

  _CppSideEchoResponseParams() : super(kVersions.last.size);

  _CppSideEchoResponseParams.init(
    EchoArgsList this.list
  ) : super(kVersions.last.size);

  static _CppSideEchoResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CppSideEchoResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CppSideEchoResponseParams result = new _CppSideEchoResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.list = EchoArgsList.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CppSideEchoResponseParams";
    String fieldName;
    try {
      fieldName = "list";
      encoder0.encodeStruct(list, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CppSideEchoResponseParams("
           "list: $list" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _DartSideSetClientParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  CppSideInterface cppSide = null;

  _DartSideSetClientParams() : super(kVersions.last.size);

  _DartSideSetClientParams.init(
    CppSideInterface this.cppSide
  ) : super(kVersions.last.size);

  static _DartSideSetClientParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _DartSideSetClientParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _DartSideSetClientParams result = new _DartSideSetClientParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.cppSide = decoder0.decodeServiceInterface(8, false, CppSideProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_DartSideSetClientParams";
    String fieldName;
    try {
      fieldName = "cppSide";
      encoder0.encodeInterface(cppSide, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_DartSideSetClientParams("
           "cppSide: $cppSide" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _DartSidePingParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _DartSidePingParams() : super(kVersions.last.size);

  _DartSidePingParams.init(
  ) : super(kVersions.last.size);

  static _DartSidePingParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _DartSidePingParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _DartSidePingParams result = new _DartSidePingParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_DartSidePingParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_DartSidePingParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _DartSideEchoParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int numIterations = 0;
  EchoArgs arg = null;

  _DartSideEchoParams() : super(kVersions.last.size);

  _DartSideEchoParams.init(
    int this.numIterations, 
    EchoArgs this.arg
  ) : super(kVersions.last.size);

  static _DartSideEchoParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _DartSideEchoParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _DartSideEchoParams result = new _DartSideEchoParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.numIterations = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.arg = EchoArgs.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_DartSideEchoParams";
    String fieldName;
    try {
      fieldName = "numIterations";
      encoder0.encodeInt32(numIterations, 8);
      fieldName = "arg";
      encoder0.encodeStruct(arg, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_DartSideEchoParams("
           "numIterations: $numIterations" ", "
           "arg: $arg" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}

const int _cppSideMethodStartTestName = 88888888;
const int _cppSideMethodTestFinishedName = 99999999;
const int _cppSideMethodPingResponseName = 100000000;
const int _cppSideMethodEchoResponseName = 100000001;

class _CppSideServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CppSide {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CppSideServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CppSideProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CppSideProxy p = new CppSideProxy.unbound();
    String name = serviceName ?? CppSide.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void startTest();
  void testFinished();
  void pingResponse();
  void echoResponse(EchoArgsList list);
}

abstract class CppSideInterface
    implements bindings.MojoInterface<CppSide>,
               CppSide {
  factory CppSideInterface([CppSide impl]) =>
      new CppSideStub.unbound(impl);

  factory CppSideInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CppSide impl]) =>
      new CppSideStub.fromEndpoint(endpoint, impl);

  factory CppSideInterface.fromMock(
      CppSide mock) =>
      new CppSideProxy.fromMock(mock);
}

abstract class CppSideInterfaceRequest
    implements bindings.MojoInterface<CppSide>,
               CppSide {
  factory CppSideInterfaceRequest() =>
      new CppSideProxy.unbound();
}

class _CppSideProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CppSide> {
  CppSide impl;

  _CppSideProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CppSideProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CppSideProxyControl.unbound() : super.unbound();

  String get serviceName => CppSide.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CppSideProxyControl($superString)";
  }
}

class CppSideProxy
    extends bindings.Proxy<CppSide>
    implements CppSide,
               CppSideInterface,
               CppSideInterfaceRequest {
  CppSideProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CppSideProxyControl.fromEndpoint(endpoint));

  CppSideProxy.fromHandle(core.MojoHandle handle)
      : super(new _CppSideProxyControl.fromHandle(handle));

  CppSideProxy.unbound()
      : super(new _CppSideProxyControl.unbound());

  factory CppSideProxy.fromMock(CppSide mock) {
    CppSideProxy newMockedProxy =
        new CppSideProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CppSideProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CppSideProxy"));
    return new CppSideProxy.fromEndpoint(endpoint);
  }


  void startTest() {
    if (impl != null) {
      impl.startTest();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideStartTestParams();
    ctrl.sendMessage(params,
        _cppSideMethodStartTestName);
  }
  void testFinished() {
    if (impl != null) {
      impl.testFinished();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideTestFinishedParams();
    ctrl.sendMessage(params,
        _cppSideMethodTestFinishedName);
  }
  void pingResponse() {
    if (impl != null) {
      impl.pingResponse();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSidePingResponseParams();
    ctrl.sendMessage(params,
        _cppSideMethodPingResponseName);
  }
  void echoResponse(EchoArgsList list) {
    if (impl != null) {
      impl.echoResponse(list);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CppSideEchoResponseParams();
    params.list = list;
    ctrl.sendMessage(params,
        _cppSideMethodEchoResponseName);
  }
}

class _CppSideStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CppSide> {
  CppSide _impl;

  _CppSideStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CppSide impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CppSideStubControl.fromHandle(
      core.MojoHandle handle, [CppSide impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CppSideStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CppSide.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _cppSideMethodStartTestName:
        _impl.startTest();
        break;
      case _cppSideMethodTestFinishedName:
        _impl.testFinished();
        break;
      case _cppSideMethodPingResponseName:
        _impl.pingResponse();
        break;
      case _cppSideMethodEchoResponseName:
        var params = _CppSideEchoResponseParams.deserialize(
            message.payload);
        _impl.echoResponse(params.list);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CppSide get impl => _impl;
  set impl(CppSide d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CppSideStubControl($superString)";
  }

  int get version => 0;
}

class CppSideStub
    extends bindings.Stub<CppSide>
    implements CppSide,
               CppSideInterface,
               CppSideInterfaceRequest {
  CppSideStub.unbound([CppSide impl])
      : super(new _CppSideStubControl.unbound(impl));

  CppSideStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CppSide impl])
      : super(new _CppSideStubControl.fromEndpoint(endpoint, impl));

  CppSideStub.fromHandle(
      core.MojoHandle handle, [CppSide impl])
      : super(new _CppSideStubControl.fromHandle(handle, impl));

  static CppSideStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CppSideStub"));
    return new CppSideStub.fromEndpoint(endpoint);
  }


  void startTest() {
    return impl.startTest();
  }
  void testFinished() {
    return impl.testFinished();
  }
  void pingResponse() {
    return impl.pingResponse();
  }
  void echoResponse(EchoArgsList list) {
    return impl.echoResponse(list);
  }
}

const int _dartSideMethodSetClientName = 0;
const int _dartSideMethodPingName = 1;
const int _dartSideMethodEchoName = 2;

class _DartSideServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class DartSide {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _DartSideServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static DartSideProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    DartSideProxy p = new DartSideProxy.unbound();
    String name = serviceName ?? DartSide.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setClient(CppSideInterface cppSide);
  void ping();
  void echo(int numIterations, EchoArgs arg);
}

abstract class DartSideInterface
    implements bindings.MojoInterface<DartSide>,
               DartSide {
  factory DartSideInterface([DartSide impl]) =>
      new DartSideStub.unbound(impl);

  factory DartSideInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [DartSide impl]) =>
      new DartSideStub.fromEndpoint(endpoint, impl);

  factory DartSideInterface.fromMock(
      DartSide mock) =>
      new DartSideProxy.fromMock(mock);
}

abstract class DartSideInterfaceRequest
    implements bindings.MojoInterface<DartSide>,
               DartSide {
  factory DartSideInterfaceRequest() =>
      new DartSideProxy.unbound();
}

class _DartSideProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<DartSide> {
  DartSide impl;

  _DartSideProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _DartSideProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _DartSideProxyControl.unbound() : super.unbound();

  String get serviceName => DartSide.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_DartSideProxyControl($superString)";
  }
}

class DartSideProxy
    extends bindings.Proxy<DartSide>
    implements DartSide,
               DartSideInterface,
               DartSideInterfaceRequest {
  DartSideProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _DartSideProxyControl.fromEndpoint(endpoint));

  DartSideProxy.fromHandle(core.MojoHandle handle)
      : super(new _DartSideProxyControl.fromHandle(handle));

  DartSideProxy.unbound()
      : super(new _DartSideProxyControl.unbound());

  factory DartSideProxy.fromMock(DartSide mock) {
    DartSideProxy newMockedProxy =
        new DartSideProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static DartSideProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For DartSideProxy"));
    return new DartSideProxy.fromEndpoint(endpoint);
  }


  void setClient(CppSideInterface cppSide) {
    if (impl != null) {
      impl.setClient(cppSide);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _DartSideSetClientParams();
    params.cppSide = cppSide;
    ctrl.sendMessage(params,
        _dartSideMethodSetClientName);
  }
  void ping() {
    if (impl != null) {
      impl.ping();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _DartSidePingParams();
    ctrl.sendMessage(params,
        _dartSideMethodPingName);
  }
  void echo(int numIterations, EchoArgs arg) {
    if (impl != null) {
      impl.echo(numIterations, arg);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _DartSideEchoParams();
    params.numIterations = numIterations;
    params.arg = arg;
    ctrl.sendMessage(params,
        _dartSideMethodEchoName);
  }
}

class _DartSideStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<DartSide> {
  DartSide _impl;

  _DartSideStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [DartSide impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _DartSideStubControl.fromHandle(
      core.MojoHandle handle, [DartSide impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _DartSideStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => DartSide.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _dartSideMethodSetClientName:
        var params = _DartSideSetClientParams.deserialize(
            message.payload);
        _impl.setClient(params.cppSide);
        break;
      case _dartSideMethodPingName:
        _impl.ping();
        break;
      case _dartSideMethodEchoName:
        var params = _DartSideEchoParams.deserialize(
            message.payload);
        _impl.echo(params.numIterations, params.arg);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  DartSide get impl => _impl;
  set impl(DartSide d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_DartSideStubControl($superString)";
  }

  int get version => 0;
}

class DartSideStub
    extends bindings.Stub<DartSide>
    implements DartSide,
               DartSideInterface,
               DartSideInterfaceRequest {
  DartSideStub.unbound([DartSide impl])
      : super(new _DartSideStubControl.unbound(impl));

  DartSideStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [DartSide impl])
      : super(new _DartSideStubControl.fromEndpoint(endpoint, impl));

  DartSideStub.fromHandle(
      core.MojoHandle handle, [DartSide impl])
      : super(new _DartSideStubControl.fromHandle(handle, impl));

  static DartSideStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For DartSideStub"));
    return new DartSideStub.fromEndpoint(endpoint);
  }


  void setClient(CppSideInterface cppSide) {
    return impl.setClient(cppSide);
  }
  void ping() {
    return impl.ping();
  }
  void echo(int numIterations, EchoArgs arg) {
    return impl.echo(numIterations, arg);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/9yaP2zbxhfHScqyJdmyZdlO9Ps1TVUgQd2iNp0/CIROKlIXLprBaIIimRRGukgsKFIhqSLdMnbs6DFjx4wdO2bsmDHdMmYJkC29qx7l8/nudCJU6iACDyeaB/Pe57737t0da8boqkB5ACX796QsMCVb7xWUu9iWsNXhvgnlQyifQXkF2yVs9x4cH7a+P3zwVccJ41YctNqDwf7tweCu20Gk3lVsH4vqfYN/Q0VpvcN2L/g67Eb4+efYPp1U744bxdDOI/CH+JnD1qD8JvevVk/vTWzPL56939075WJQXMaXefa2yTxO+iV57we4jgz+tYFtBVuC8CP8ewubAO+5fiQcS9h60Gf2MAptL2g7nt0Ngq6H7F7QR7br+F7gtu34id0PfgrsKGyPfpD32EPfjWMUxZGN+o9Qp4PCFrlFoU03g9Tvs++vU/oi3Bs/3sl/eP0ub/z9Lm9iY/V1ZI3KwdKoPFnm837LcCL/V8abrXcg4L2JrYjtbow9u4fGumH9+gyblSHXOtOOt0w5ye9EZw2B3/8D38d+74XoyVDsf3Jl5X/BODsO2bhlMPFskl7+1aAKN1zPlOhlG9saiT+43d+6vhv1UIfH64sF08sl8J32m5bMoumFxCtVbpaCXo5dv/sDigaBHyEer70F1Qvt9yLrxZxCLzkFvZBURqaXfU30MrBmqxfab530wuqkyeR15DkRwHtD7VLhReuOvdYgj/JcPp99YJq1PgxBPkjrmk7Rp83nZePVpN6bVb5egbYkS5lEx4Jlzrl+uqZJvr4N66EEkUU9z1HtfgGVXuYV59Ep9T4xT0fxbc9FvihPva5JXHxozThPT/zWLE/XLS4m6+c2rJF5+tjWIC7WBOt91X2VtHHwjSAcqnA3FeYjku/xdHljzuPyDVOqjkuVvH6R8lpWH9YUvCwFfZApncfppib6eJqbrT6Ivzrpowacx/O/KY7bBsTuWcZtEa8dbGVs/rD/HW64E7t4BSDQSTlDXtPOZ4UUXGRxdRXyLyfsGqJxc1Wj+SzJh5PUXXVfXxavLOqeHbfJBHZ/Z7b5fNI0Xj5PNftcfxRhPs+qP07wO6rYfoP3nwCP5xC4f4d49gL21/+AAf0n7LO/XBmVfwH410XIY0tU4Cb+lYH/OnDdgP17cPzXTXhfVR5PljNeH0furZu8fipBP88zjsji66zjyCmPG9d5PFY14bEkaf+0PCwlHtdu8XisacIjJ2j/egoeOYV5JnIb3HmmnHFcE/EoSeL2tDyWFPQxFMSPdYj18+ZRFLS/loJHXokHP35saMKjINlfnpbHshIPfvyoaMJjRbJPMi2PFYX4MRTEj01N4qklaH89BY+Cwn7lYy9w4tbPjifYr6tqzuVKCi5FZS6u/1jAZUtzLrspuJSUufiOL+CyrQkXU+DHQQouqxIuVZjzO8HwkYdOBxLLZUeTeCvi0kjBZU2dy3ggsVwuaM6lmYJLWZ3LeCCxXC5qwMWU7CMdpeCyrpCv+E6few5Zy/gcsiI4f6D5WBLhHKfgs6Hw3UUUh67fbTlh6PzC45Scx2W932aCD+w+mWjdQ3NcknD8MgXHioTjBVgb9VEUOV3U6jl+x0PnOf4f2M5Db2YKTvdTcNqUcNqCnLnjxM4YEkdv5Pvfy3PiZE3Yl61Cu3j7sgXg+H7CeUqT2Zc9VjhPoT8JqcM7RZ+NsDwvZ7yPwZ63PDP1+n7IR0+551KfwO95xLn/8vuheZ/nJNzdGPV53OtQZ97cszrP+ScAAP//z5Ilg8gyAAA=";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
