// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library regression_tests_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class EnumWithReference extends bindings.MojoEnum {
  static const EnumWithReference kStereoAndKeyboardMic = const EnumWithReference._(30);
  static const EnumWithReference kMax = const EnumWithReference._(30);

  const EnumWithReference._(int v) : super(v);

  static const Map<String, EnumWithReference> valuesMap = const {
    "kStereoAndKeyboardMic": kStereoAndKeyboardMic,
    "kMax": kMax,
  };
  static const List<EnumWithReference> values = const [
    kStereoAndKeyboardMic,
    kMax,
  ];

  static EnumWithReference valueOf(String name) => valuesMap[name];

  factory EnumWithReference(int v) {
    switch (v) {
      case 30:
        return EnumWithReference.kStereoAndKeyboardMic;
      case 30:
        return EnumWithReference.kMax;
      default:
        return null;
    }
  }

  static EnumWithReference decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithReference result = new EnumWithReference(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithReference.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case kStereoAndKeyboardMic:
        return 'EnumWithReference.kStereoAndKeyboardMic';
      case kMax:
        return 'EnumWithReference.kMax';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithLowercase extends bindings.MojoEnum {
  static const EnumWithLowercase planarF16 = const EnumWithLowercase._(0);
  static const EnumWithLowercase planarF32 = const EnumWithLowercase._(1);

  const EnumWithLowercase._(int v) : super(v);

  static const Map<String, EnumWithLowercase> valuesMap = const {
    "planarF16": planarF16,
    "planarF32": planarF32,
  };
  static const List<EnumWithLowercase> values = const [
    planarF16,
    planarF32,
  ];

  static EnumWithLowercase valueOf(String name) => valuesMap[name];

  factory EnumWithLowercase(int v) {
    switch (v) {
      case 0:
        return EnumWithLowercase.planarF16;
      case 1:
        return EnumWithLowercase.planarF32;
      default:
        return null;
    }
  }

  static EnumWithLowercase decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithLowercase result = new EnumWithLowercase(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithLowercase.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case planarF16:
        return 'EnumWithLowercase.planarF16';
      case planarF32:
        return 'EnumWithLowercase.planarF32';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithNumbers extends bindings.MojoEnum {
  static const EnumWithNumbers k21 = const EnumWithNumbers._(4);

  const EnumWithNumbers._(int v) : super(v);

  static const Map<String, EnumWithNumbers> valuesMap = const {
    "k21": k21,
  };
  static const List<EnumWithNumbers> values = const [
    k21,
  ];

  static EnumWithNumbers valueOf(String name) => valuesMap[name];

  factory EnumWithNumbers(int v) {
    switch (v) {
      case 4:
        return EnumWithNumbers.k21;
      default:
        return null;
    }
  }

  static EnumWithNumbers decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithNumbers result = new EnumWithNumbers(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithNumbers.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k21:
        return 'EnumWithNumbers.k21';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithK extends bindings.MojoEnum {
  static const EnumWithK k = const EnumWithK._(0);

  const EnumWithK._(int v) : super(v);

  static const Map<String, EnumWithK> valuesMap = const {
    "k": k,
  };
  static const List<EnumWithK> values = const [
    k,
  ];

  static EnumWithK valueOf(String name) => valuesMap[name];

  factory EnumWithK(int v) {
    switch (v) {
      case 0:
        return EnumWithK.k;
      default:
        return null;
    }
  }

  static EnumWithK decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithK result = new EnumWithK(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithK.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k:
        return 'EnumWithK.k';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithInternalAllCaps extends bindings.MojoEnum {
  static const EnumWithInternalAllCaps standard = const EnumWithInternalAllCaps._(0);
  static const EnumWithInternalAllCaps fullscreen = const EnumWithInternalAllCaps._(1);
  static const EnumWithInternalAllCaps immersive = const EnumWithInternalAllCaps._(2);

  const EnumWithInternalAllCaps._(int v) : super(v);

  static const Map<String, EnumWithInternalAllCaps> valuesMap = const {
    "standard": standard,
    "fullscreen": fullscreen,
    "immersive": immersive,
  };
  static const List<EnumWithInternalAllCaps> values = const [
    standard,
    fullscreen,
    immersive,
  ];

  static EnumWithInternalAllCaps valueOf(String name) => valuesMap[name];

  factory EnumWithInternalAllCaps(int v) {
    switch (v) {
      case 0:
        return EnumWithInternalAllCaps.standard;
      case 1:
        return EnumWithInternalAllCaps.fullscreen;
      case 2:
        return EnumWithInternalAllCaps.immersive;
      default:
        return null;
    }
  }

  static EnumWithInternalAllCaps decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithInternalAllCaps result = new EnumWithInternalAllCaps(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithInternalAllCaps.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case standard:
        return 'EnumWithInternalAllCaps.standard';
      case fullscreen:
        return 'EnumWithInternalAllCaps.fullscreen';
      case immersive:
        return 'EnumWithInternalAllCaps.immersive';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class NormalEnum extends bindings.MojoEnum {
  static const NormalEnum first = const NormalEnum._(0);
  static const NormalEnum second = const NormalEnum._(1);

  const NormalEnum._(int v) : super(v);

  static const Map<String, NormalEnum> valuesMap = const {
    "first": first,
    "second": second,
  };
  static const List<NormalEnum> values = const [
    first,
    second,
  ];

  static NormalEnum valueOf(String name) => valuesMap[name];

  factory NormalEnum(int v) {
    switch (v) {
      case 0:
        return NormalEnum.first;
      case 1:
        return NormalEnum.second;
      default:
        return null;
    }
  }

  static NormalEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    NormalEnum result = new NormalEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum NormalEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case first:
        return 'NormalEnum.first';
      case second:
        return 'NormalEnum.second';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class CamelCaseTestEnum extends bindings.MojoEnum {
  static const CamelCaseTestEnum boolThing = const CamelCaseTestEnum._(0);
  static const CamelCaseTestEnum doubleThing = const CamelCaseTestEnum._(1);
  static const CamelCaseTestEnum floatThing = const CamelCaseTestEnum._(2);
  static const CamelCaseTestEnum int8Thing = const CamelCaseTestEnum._(3);
  static const CamelCaseTestEnum int16Thing = const CamelCaseTestEnum._(4);
  static const CamelCaseTestEnum int32Th1Ng = const CamelCaseTestEnum._(5);
  static const CamelCaseTestEnum int64Th1ng = const CamelCaseTestEnum._(6);
  static const CamelCaseTestEnum uint8TH1ng = const CamelCaseTestEnum._(7);
  static const CamelCaseTestEnum uint16tH1Ng = const CamelCaseTestEnum._(8);
  static const CamelCaseTestEnum uint32Th1ng = const CamelCaseTestEnum._(9);
  static const CamelCaseTestEnum uint64Th1Ng = const CamelCaseTestEnum._(10);

  const CamelCaseTestEnum._(int v) : super(v);

  static const Map<String, CamelCaseTestEnum> valuesMap = const {
    "boolThing": boolThing,
    "doubleThing": doubleThing,
    "floatThing": floatThing,
    "int8Thing": int8Thing,
    "int16Thing": int16Thing,
    "int32Th1Ng": int32Th1Ng,
    "int64Th1ng": int64Th1ng,
    "uint8TH1ng": uint8TH1ng,
    "uint16tH1Ng": uint16tH1Ng,
    "uint32Th1ng": uint32Th1ng,
    "uint64Th1Ng": uint64Th1Ng,
  };
  static const List<CamelCaseTestEnum> values = const [
    boolThing,
    doubleThing,
    floatThing,
    int8Thing,
    int16Thing,
    int32Th1Ng,
    int64Th1ng,
    uint8TH1ng,
    uint16tH1Ng,
    uint32Th1ng,
    uint64Th1Ng,
  ];

  static CamelCaseTestEnum valueOf(String name) => valuesMap[name];

  factory CamelCaseTestEnum(int v) {
    switch (v) {
      case 0:
        return CamelCaseTestEnum.boolThing;
      case 1:
        return CamelCaseTestEnum.doubleThing;
      case 2:
        return CamelCaseTestEnum.floatThing;
      case 3:
        return CamelCaseTestEnum.int8Thing;
      case 4:
        return CamelCaseTestEnum.int16Thing;
      case 5:
        return CamelCaseTestEnum.int32Th1Ng;
      case 6:
        return CamelCaseTestEnum.int64Th1ng;
      case 7:
        return CamelCaseTestEnum.uint8TH1ng;
      case 8:
        return CamelCaseTestEnum.uint16tH1Ng;
      case 9:
        return CamelCaseTestEnum.uint32Th1ng;
      case 10:
        return CamelCaseTestEnum.uint64Th1Ng;
      default:
        return null;
    }
  }

  static CamelCaseTestEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    CamelCaseTestEnum result = new CamelCaseTestEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum CamelCaseTestEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case boolThing:
        return 'CamelCaseTestEnum.boolThing';
      case doubleThing:
        return 'CamelCaseTestEnum.doubleThing';
      case floatThing:
        return 'CamelCaseTestEnum.floatThing';
      case int8Thing:
        return 'CamelCaseTestEnum.int8Thing';
      case int16Thing:
        return 'CamelCaseTestEnum.int16Thing';
      case int32Th1Ng:
        return 'CamelCaseTestEnum.int32Th1Ng';
      case int64Th1ng:
        return 'CamelCaseTestEnum.int64Th1ng';
      case uint8TH1ng:
        return 'CamelCaseTestEnum.uint8TH1ng';
      case uint16tH1Ng:
        return 'CamelCaseTestEnum.uint16tH1Ng';
      case uint32Th1ng:
        return 'CamelCaseTestEnum.uint32Th1ng';
      case uint64Th1Ng:
        return 'CamelCaseTestEnum.uint64Th1Ng';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class Edge extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Vertex v = null;

  Edge() : super(kVersions.last.size);

  Edge.init(
    Vertex this.v
  ) : super(kVersions.last.size);

  static Edge deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Edge decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Edge result = new Edge();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.v = Vertex.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Edge";
    String fieldName;
    try {
      fieldName = "v";
      encoder0.encodeStruct(v, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Edge("
           "v: $v" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["v"] = v;
    return map;
  }
}


class Vertex extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EmptyStruct e = null;

  Vertex() : super(kVersions.last.size);

  Vertex.init(
    EmptyStruct this.e
  ) : super(kVersions.last.size);

  static Vertex deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Vertex decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Vertex result = new Vertex();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.e = EmptyStruct.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Vertex";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeStruct(e, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Vertex("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class EmptyStruct extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  EmptyStruct() : super(kVersions.last.size);

  EmptyStruct.init(
  ) : super(kVersions.last.size);

  static EmptyStruct deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EmptyStruct decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EmptyStruct result = new EmptyStruct();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EmptyStruct";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EmptyStruct("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class A extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  B b = null;

  A() : super(kVersions.last.size);

  A.init(
    B this.b
  ) : super(kVersions.last.size);

  static A deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static A decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    A result = new A();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.b = B.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "A";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeStruct(b, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "A("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class B extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  A a = null;

  B() : super(kVersions.last.size);

  B.init(
    A this.a
  ) : super(kVersions.last.size);

  static B deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static B decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    B result = new B();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.a = A.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "B";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeStruct(a, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "B("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class StructWithHandleCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoHandle handles = null;

  StructWithHandleCalledHandles() : super(kVersions.last.size);

  StructWithHandleCalledHandles.init(
    core.MojoHandle this.handles
  ) : super(kVersions.last.size);

  static StructWithHandleCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHandleCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHandleCalledHandles result = new StructWithHandleCalledHandles();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHandleCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandle(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHandleCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithArrayOfHandlesCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<core.MojoHandle> handles = null;

  StructWithArrayOfHandlesCalledHandles() : super(kVersions.last.size);

  StructWithArrayOfHandlesCalledHandles.init(
    List<core.MojoHandle> this.handles
  ) : super(kVersions.last.size);

  static StructWithArrayOfHandlesCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithArrayOfHandlesCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithArrayOfHandlesCalledHandles result = new StructWithArrayOfHandlesCalledHandles();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithArrayOfHandlesCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandleArray(handles, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithArrayOfHandlesCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithInterfaceCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  TestInterfaceInterface handles = null;

  StructWithInterfaceCalledHandles() : super(kVersions.last.size);

  StructWithInterfaceCalledHandles.init(
    TestInterfaceInterface this.handles
  ) : super(kVersions.last.size);

  static StructWithInterfaceCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterfaceCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterfaceCalledHandles result = new StructWithInterfaceCalledHandles();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeServiceInterface(8, false, TestInterfaceProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterfaceCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeInterface(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterfaceCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ContainsArrayOfEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<NormalEnum> arrayOfEnums = null;

  ContainsArrayOfEnum() : super(kVersions.last.size);

  ContainsArrayOfEnum.init(
    List<NormalEnum> this.arrayOfEnums
  ) : super(kVersions.last.size);

  static ContainsArrayOfEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ContainsArrayOfEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ContainsArrayOfEnum result = new ContainsArrayOfEnum();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForEnumArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfEnums = new List<NormalEnum>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.arrayOfEnums[i1] = NormalEnum.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i1);
            if (result.arrayOfEnums[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable NormalEnum.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ContainsArrayOfEnum";
    String fieldName;
    try {
      fieldName = "arrayOfEnums";
      if (arrayOfEnums == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodeEnumArray(arrayOfEnums.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < arrayOfEnums.length; ++i0) {
          encoder1.encodeEnum(arrayOfEnums[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i0);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ContainsArrayOfEnum("
           "arrayOfEnums: $arrayOfEnums" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["arrayOfEnums"] = arrayOfEnums;
    return map;
  }
}


class ContainsNullableArrayOfEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<NormalEnum> arrayOfEnums = null;

  ContainsNullableArrayOfEnum() : super(kVersions.last.size);

  ContainsNullableArrayOfEnum.init(
    List<NormalEnum> this.arrayOfEnums
  ) : super(kVersions.last.size);

  static ContainsNullableArrayOfEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ContainsNullableArrayOfEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ContainsNullableArrayOfEnum result = new ContainsNullableArrayOfEnum();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      if (decoder1 == null) {
        result.arrayOfEnums = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForEnumArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfEnums = new List<NormalEnum>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.arrayOfEnums[i1] = NormalEnum.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i1);
            if (result.arrayOfEnums[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable NormalEnum.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ContainsNullableArrayOfEnum";
    String fieldName;
    try {
      fieldName = "arrayOfEnums";
      if (arrayOfEnums == null) {
        encoder0.encodeNullPointer(8, true);
      } else {
        var encoder1 = encoder0.encodeEnumArray(arrayOfEnums.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < arrayOfEnums.length; ++i0) {
          encoder1.encodeEnum(arrayOfEnums[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i0);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ContainsNullableArrayOfEnum("
           "arrayOfEnums: $arrayOfEnums" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["arrayOfEnums"] = arrayOfEnums;
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams.init(
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool b = false;

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.init(
    bool this.b
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeBool(b, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckNameCollisionWithNameCollisionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  _CheckNameCollisionWithNameCollisionParams() : super(kVersions.last.size);

  _CheckNameCollisionWithNameCollisionParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static _CheckNameCollisionWithNameCollisionParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckNameCollisionWithNameCollisionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckNameCollisionWithNameCollisionParams result = new _CheckNameCollisionWithNameCollisionParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckNameCollisionWithNameCollisionParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckNameCollisionWithNameCollisionParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class CheckNameCollisionWithNameCollisionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  CheckNameCollisionWithNameCollisionResponseParams() : super(kVersions.last.size);

  CheckNameCollisionWithNameCollisionResponseParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static CheckNameCollisionWithNameCollisionResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckNameCollisionWithNameCollisionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckNameCollisionWithNameCollisionResponseParams result = new CheckNameCollisionWithNameCollisionResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckNameCollisionWithNameCollisionResponseParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckNameCollisionWithNameCollisionResponseParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class _CheckEnumCapsSetEnumWithInternalAllCapsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EnumWithInternalAllCaps e = null;

  _CheckEnumCapsSetEnumWithInternalAllCapsParams() : super(kVersions.last.size);

  _CheckEnumCapsSetEnumWithInternalAllCapsParams.init(
    EnumWithInternalAllCaps this.e
  ) : super(kVersions.last.size);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckEnumCapsSetEnumWithInternalAllCapsParams result = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.e = EnumWithInternalAllCaps.decode(decoder0, 8);
        if (result.e == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable EnumWithInternalAllCaps.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckEnumCapsSetEnumWithInternalAllCapsParams";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeEnum(e, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckEnumCapsSetEnumWithInternalAllCapsParams("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class _TestInterfaceSomeMessageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestInterfaceSomeMessageParams() : super(kVersions.last.size);

  _TestInterfaceSomeMessageParams.init(
  ) : super(kVersions.last.size);

  static _TestInterfaceSomeMessageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestInterfaceSomeMessageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestInterfaceSomeMessageParams result = new _TestInterfaceSomeMessageParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestInterfaceSomeMessageParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestInterfaceSomeMessageParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _Regression551GetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<String> keyPrefixes = null;

  _Regression551GetParams() : super(kVersions.last.size);

  _Regression551GetParams.init(
    List<String> this.keyPrefixes
  ) : super(kVersions.last.size);

  static _Regression551GetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _Regression551GetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _Regression551GetParams result = new _Regression551GetParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.keyPrefixes = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.keyPrefixes[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_Regression551GetParams";
    String fieldName;
    try {
      fieldName = "keyPrefixes";
      if (keyPrefixes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(keyPrefixes.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < keyPrefixes.length; ++i0) {
          encoder1.encodeString(keyPrefixes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_Regression551GetParams("
           "keyPrefixes: $keyPrefixes" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["keyPrefixes"] = keyPrefixes;
    return map;
  }
}


class Regression551GetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int result = 0;

  Regression551GetResponseParams() : super(kVersions.last.size);

  Regression551GetResponseParams.init(
    int this.result
  ) : super(kVersions.last.size);

  static Regression551GetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Regression551GetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Regression551GetResponseParams result = new Regression551GetResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.result = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Regression551GetResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeInt32(result, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Regression551GetResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _ServiceNameServiceNameParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _ServiceNameServiceNameParams() : super(kVersions.last.size);

  _ServiceNameServiceNameParams.init(
  ) : super(kVersions.last.size);

  static _ServiceNameServiceNameParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ServiceNameServiceNameParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ServiceNameServiceNameParams result = new _ServiceNameServiceNameParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ServiceNameServiceNameParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ServiceNameServiceNameParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class ServiceNameServiceNameResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String serviceName_ = null;

  ServiceNameServiceNameResponseParams() : super(kVersions.last.size);

  ServiceNameServiceNameResponseParams.init(
    String this.serviceName_
  ) : super(kVersions.last.size);

  static ServiceNameServiceNameResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceNameServiceNameResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceNameServiceNameResponseParams result = new ServiceNameServiceNameResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.serviceName_ = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceNameServiceNameResponseParams";
    String fieldName;
    try {
      fieldName = "serviceName_";
      encoder0.encodeString(serviceName_, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceNameServiceNameResponseParams("
           "serviceName_: $serviceName_" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["serviceName_"] = serviceName_;
    return map;
  }
}

const int _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName = 0;
const int _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName = 1;

class _CheckMethodWithEmptyResponseServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckMethodWithEmptyResponse {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckMethodWithEmptyResponseServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckMethodWithEmptyResponseProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckMethodWithEmptyResponseProxy p = new CheckMethodWithEmptyResponseProxy.unbound();
    String name = serviceName ?? CheckMethodWithEmptyResponse.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withoutParameterAndEmptyResponse(void callback());
  void withParameterAndEmptyResponse(bool b,void callback());
}

abstract class CheckMethodWithEmptyResponseInterface
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterface([CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.unbound(impl);

  factory CheckMethodWithEmptyResponseInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint, impl);

  factory CheckMethodWithEmptyResponseInterface.fromMock(
      CheckMethodWithEmptyResponse mock) =>
      new CheckMethodWithEmptyResponseProxy.fromMock(mock);
}

abstract class CheckMethodWithEmptyResponseInterfaceRequest
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterfaceRequest() =>
      new CheckMethodWithEmptyResponseProxy.unbound();
}

class _CheckMethodWithEmptyResponseProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse impl;

  _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckMethodWithEmptyResponseProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckMethodWithEmptyResponseProxyControl.unbound() : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseProxyControl($superString)";
  }
}

class CheckMethodWithEmptyResponseProxy
    extends bindings.Proxy<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(endpoint));

  CheckMethodWithEmptyResponseProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromHandle(handle));

  CheckMethodWithEmptyResponseProxy.unbound()
      : super(new _CheckMethodWithEmptyResponseProxyControl.unbound());

  factory CheckMethodWithEmptyResponseProxy.fromMock(CheckMethodWithEmptyResponse mock) {
    CheckMethodWithEmptyResponseProxy newMockedProxy =
        new CheckMethodWithEmptyResponseProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckMethodWithEmptyResponseProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseProxy"));
    return new CheckMethodWithEmptyResponseProxy.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    if (impl != null) {
      impl.withoutParameterAndEmptyResponse(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    if (impl != null) {
      impl.withParameterAndEmptyResponse(b,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();
    params.b = b;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckMethodWithEmptyResponseStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse _impl;

  _CheckMethodWithEmptyResponseStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;


  Function _checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        _impl.withoutParameterAndEmptyResponse(_checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        var params = _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.deserialize(
            message.payload);
        _impl.withParameterAndEmptyResponse(params.b, _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckMethodWithEmptyResponse get impl => _impl;
  set impl(CheckMethodWithEmptyResponse d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseStubControl($superString)";
  }

  int get version => 0;
}

class CheckMethodWithEmptyResponseStub
    extends bindings.Stub<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseStub.unbound([CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.unbound(impl));

  CheckMethodWithEmptyResponseStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromEndpoint(endpoint, impl));

  CheckMethodWithEmptyResponseStub.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromHandle(handle, impl));

  static CheckMethodWithEmptyResponseStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseStub"));
    return new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    return impl.withoutParameterAndEmptyResponse(callback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    return impl.withParameterAndEmptyResponse(b,callback);
  }
}

const int _checkNameCollisionMethodWithNameCollisionName = 0;

class _CheckNameCollisionServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckNameCollision {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckNameCollisionServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckNameCollisionProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckNameCollisionProxy p = new CheckNameCollisionProxy.unbound();
    String name = serviceName ?? CheckNameCollision.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withNameCollision(bool message,bool response,void callback(bool message, bool response));
}

abstract class CheckNameCollisionInterface
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterface([CheckNameCollision impl]) =>
      new CheckNameCollisionStub.unbound(impl);

  factory CheckNameCollisionInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckNameCollision impl]) =>
      new CheckNameCollisionStub.fromEndpoint(endpoint, impl);

  factory CheckNameCollisionInterface.fromMock(
      CheckNameCollision mock) =>
      new CheckNameCollisionProxy.fromMock(mock);
}

abstract class CheckNameCollisionInterfaceRequest
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterfaceRequest() =>
      new CheckNameCollisionProxy.unbound();
}

class _CheckNameCollisionProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckNameCollision> {
  CheckNameCollision impl;

  _CheckNameCollisionProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckNameCollisionProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckNameCollisionProxyControl.unbound() : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CheckNameCollisionWithNameCollisionResponseParams.deserialize(
              message.payload);
          callback(r.message , r.response );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionProxyControl($superString)";
  }
}

class CheckNameCollisionProxy
    extends bindings.Proxy<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckNameCollisionProxyControl.fromEndpoint(endpoint));

  CheckNameCollisionProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckNameCollisionProxyControl.fromHandle(handle));

  CheckNameCollisionProxy.unbound()
      : super(new _CheckNameCollisionProxyControl.unbound());

  factory CheckNameCollisionProxy.fromMock(CheckNameCollision mock) {
    CheckNameCollisionProxy newMockedProxy =
        new CheckNameCollisionProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckNameCollisionProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionProxy"));
    return new CheckNameCollisionProxy.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    if (impl != null) {
      impl.withNameCollision(message,response,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CheckNameCollisionWithNameCollisionParams();
    params.message = message;
    params.response = response;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((bool message, bool response) {
        z.bindCallback(() {
          callback(message, response);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkNameCollisionMethodWithNameCollisionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckNameCollisionStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckNameCollision> {
  CheckNameCollision _impl;

  _CheckNameCollisionStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;


  Function _checkNameCollisionWithNameCollisionResponseParamsResponder(
      int requestId) {
  return (bool message, bool response) {
      var result = new CheckNameCollisionWithNameCollisionResponseParams();
      result.message = message;
      result.response = response;
      sendResponse(buildResponseWithId(
          result,
          _checkNameCollisionMethodWithNameCollisionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        var params = _CheckNameCollisionWithNameCollisionParams.deserialize(
            message.payload);
        _impl.withNameCollision(params.message, params.response, _checkNameCollisionWithNameCollisionResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckNameCollision get impl => _impl;
  set impl(CheckNameCollision d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionStubControl($superString)";
  }

  int get version => 0;
}

class CheckNameCollisionStub
    extends bindings.Stub<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionStub.unbound([CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.unbound(impl));

  CheckNameCollisionStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromEndpoint(endpoint, impl));

  CheckNameCollisionStub.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromHandle(handle, impl));

  static CheckNameCollisionStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionStub"));
    return new CheckNameCollisionStub.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    return impl.withNameCollision(message,response,callback);
  }
}

const int _checkEnumCapsMethodSetEnumWithInternalAllCapsName = 0;

class _CheckEnumCapsServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckEnumCaps {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckEnumCapsServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckEnumCapsProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckEnumCapsProxy p = new CheckEnumCapsProxy.unbound();
    String name = serviceName ?? CheckEnumCaps.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e);
}

abstract class CheckEnumCapsInterface
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterface([CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.unbound(impl);

  factory CheckEnumCapsInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.fromEndpoint(endpoint, impl);

  factory CheckEnumCapsInterface.fromMock(
      CheckEnumCaps mock) =>
      new CheckEnumCapsProxy.fromMock(mock);
}

abstract class CheckEnumCapsInterfaceRequest
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterfaceRequest() =>
      new CheckEnumCapsProxy.unbound();
}

class _CheckEnumCapsProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckEnumCaps> {
  CheckEnumCaps impl;

  _CheckEnumCapsProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckEnumCapsProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckEnumCapsProxyControl.unbound() : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsProxyControl($superString)";
  }
}

class CheckEnumCapsProxy
    extends bindings.Proxy<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckEnumCapsProxyControl.fromEndpoint(endpoint));

  CheckEnumCapsProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckEnumCapsProxyControl.fromHandle(handle));

  CheckEnumCapsProxy.unbound()
      : super(new _CheckEnumCapsProxyControl.unbound());

  factory CheckEnumCapsProxy.fromMock(CheckEnumCaps mock) {
    CheckEnumCapsProxy newMockedProxy =
        new CheckEnumCapsProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckEnumCapsProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsProxy"));
    return new CheckEnumCapsProxy.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    if (impl != null) {
      impl.setEnumWithInternalAllCaps(e);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();
    params.e = e;
    ctrl.sendMessage(params,
        _checkEnumCapsMethodSetEnumWithInternalAllCapsName);
  }
}

class _CheckEnumCapsStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckEnumCaps> {
  CheckEnumCaps _impl;

  _CheckEnumCapsStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkEnumCapsMethodSetEnumWithInternalAllCapsName:
        var params = _CheckEnumCapsSetEnumWithInternalAllCapsParams.deserialize(
            message.payload);
        _impl.setEnumWithInternalAllCaps(params.e);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckEnumCaps get impl => _impl;
  set impl(CheckEnumCaps d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsStubControl($superString)";
  }

  int get version => 0;
}

class CheckEnumCapsStub
    extends bindings.Stub<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsStub.unbound([CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.unbound(impl));

  CheckEnumCapsStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromEndpoint(endpoint, impl));

  CheckEnumCapsStub.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromHandle(handle, impl));

  static CheckEnumCapsStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsStub"));
    return new CheckEnumCapsStub.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    return impl.setEnumWithInternalAllCaps(e);
  }
}

const int _testInterfaceMethodSomeMessageName = 0;

class _TestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestInterfaceProxy p = new TestInterfaceProxy.unbound();
    String name = serviceName ?? TestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void someMessage();
}

abstract class TestInterfaceInterface
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterface([TestInterface impl]) =>
      new TestInterfaceStub.unbound(impl);

  factory TestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestInterface impl]) =>
      new TestInterfaceStub.fromEndpoint(endpoint, impl);

  factory TestInterfaceInterface.fromMock(
      TestInterface mock) =>
      new TestInterfaceProxy.fromMock(mock);
}

abstract class TestInterfaceInterfaceRequest
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterfaceRequest() =>
      new TestInterfaceProxy.unbound();
}

class _TestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestInterface> {
  TestInterface impl;

  _TestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => TestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceProxyControl($superString)";
  }
}

class TestInterfaceProxy
    extends bindings.Proxy<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestInterfaceProxyControl.fromEndpoint(endpoint));

  TestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestInterfaceProxyControl.fromHandle(handle));

  TestInterfaceProxy.unbound()
      : super(new _TestInterfaceProxyControl.unbound());

  factory TestInterfaceProxy.fromMock(TestInterface mock) {
    TestInterfaceProxy newMockedProxy =
        new TestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceProxy"));
    return new TestInterfaceProxy.fromEndpoint(endpoint);
  }


  void someMessage() {
    if (impl != null) {
      impl.someMessage();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestInterfaceSomeMessageParams();
    ctrl.sendMessage(params,
        _testInterfaceMethodSomeMessageName);
  }
}

class _TestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestInterface> {
  TestInterface _impl;

  _TestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestInterface.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testInterfaceMethodSomeMessageName:
        _impl.someMessage();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestInterface get impl => _impl;
  set impl(TestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class TestInterfaceStub
    extends bindings.Stub<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceStub.unbound([TestInterface impl])
      : super(new _TestInterfaceStubControl.unbound(impl));

  TestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromEndpoint(endpoint, impl));

  TestInterfaceStub.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromHandle(handle, impl));

  static TestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceStub"));
    return new TestInterfaceStub.fromEndpoint(endpoint);
  }


  void someMessage() {
    return impl.someMessage();
  }
}

const int _regression551MethodGetName = 0;

class _Regression551ServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Regression551 {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _Regression551ServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static Regression551Proxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    Regression551Proxy p = new Regression551Proxy.unbound();
    String name = serviceName ?? Regression551.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void get(List<String> keyPrefixes,void callback(int result));
}

abstract class Regression551Interface
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551Interface([Regression551 impl]) =>
      new Regression551Stub.unbound(impl);

  factory Regression551Interface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Regression551 impl]) =>
      new Regression551Stub.fromEndpoint(endpoint, impl);

  factory Regression551Interface.fromMock(
      Regression551 mock) =>
      new Regression551Proxy.fromMock(mock);
}

abstract class Regression551InterfaceRequest
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551InterfaceRequest() =>
      new Regression551Proxy.unbound();
}

class _Regression551ProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Regression551> {
  Regression551 impl;

  _Regression551ProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _Regression551ProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _Regression551ProxyControl.unbound() : super.unbound();

  String get serviceName => Regression551.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _regression551MethodGetName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = Regression551GetResponseParams.deserialize(
              message.payload);
          callback(r.result );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551ProxyControl($superString)";
  }
}

class Regression551Proxy
    extends bindings.Proxy<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Proxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _Regression551ProxyControl.fromEndpoint(endpoint));

  Regression551Proxy.fromHandle(core.MojoHandle handle)
      : super(new _Regression551ProxyControl.fromHandle(handle));

  Regression551Proxy.unbound()
      : super(new _Regression551ProxyControl.unbound());

  factory Regression551Proxy.fromMock(Regression551 mock) {
    Regression551Proxy newMockedProxy =
        new Regression551Proxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static Regression551Proxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Proxy"));
    return new Regression551Proxy.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    if (impl != null) {
      impl.get(keyPrefixes,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _Regression551GetParams();
    params.keyPrefixes = keyPrefixes;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _regression551MethodGetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _Regression551StubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Regression551> {
  Regression551 _impl;

  _Regression551StubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Regression551.serviceName;


  Function _regression551GetResponseParamsResponder(
      int requestId) {
  return (int result) {
      var result = new Regression551GetResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _regression551MethodGetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _regression551MethodGetName:
        var params = _Regression551GetParams.deserialize(
            message.payload);
        _impl.get(params.keyPrefixes, _regression551GetResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Regression551 get impl => _impl;
  set impl(Regression551 d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551StubControl($superString)";
  }

  int get version => 0;
}

class Regression551Stub
    extends bindings.Stub<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Stub.unbound([Regression551 impl])
      : super(new _Regression551StubControl.unbound(impl));

  Regression551Stub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super(new _Regression551StubControl.fromEndpoint(endpoint, impl));

  Regression551Stub.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super(new _Regression551StubControl.fromHandle(handle, impl));

  static Regression551Stub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Stub"));
    return new Regression551Stub.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    return impl.get(keyPrefixes,callback);
  }
}

const int _serviceNameMethodServiceNameName = 0;

class _ServiceNameServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ServiceName {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ServiceNameServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ServiceNameProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ServiceNameProxy p = new ServiceNameProxy.unbound();
    String name = serviceName ?? ServiceName.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void serviceName_(void callback(String serviceName_));
}

abstract class ServiceNameInterface
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterface([ServiceName impl]) =>
      new ServiceNameStub.unbound(impl);

  factory ServiceNameInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ServiceName impl]) =>
      new ServiceNameStub.fromEndpoint(endpoint, impl);

  factory ServiceNameInterface.fromMock(
      ServiceName mock) =>
      new ServiceNameProxy.fromMock(mock);
}

abstract class ServiceNameInterfaceRequest
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterfaceRequest() =>
      new ServiceNameProxy.unbound();
}

class _ServiceNameProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ServiceName> {
  ServiceName impl;

  _ServiceNameProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ServiceNameProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ServiceNameProxyControl.unbound() : super.unbound();

  String get serviceName => ServiceName.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = ServiceNameServiceNameResponseParams.deserialize(
              message.payload);
          callback(r.serviceName_ );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameProxyControl($superString)";
  }
}

class ServiceNameProxy
    extends bindings.Proxy<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ServiceNameProxyControl.fromEndpoint(endpoint));

  ServiceNameProxy.fromHandle(core.MojoHandle handle)
      : super(new _ServiceNameProxyControl.fromHandle(handle));

  ServiceNameProxy.unbound()
      : super(new _ServiceNameProxyControl.unbound());

  factory ServiceNameProxy.fromMock(ServiceName mock) {
    ServiceNameProxy newMockedProxy =
        new ServiceNameProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ServiceNameProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameProxy"));
    return new ServiceNameProxy.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    if (impl != null) {
      impl.serviceName_(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _ServiceNameServiceNameParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String serviceName_) {
        z.bindCallback(() {
          callback(serviceName_);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _serviceNameMethodServiceNameName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _ServiceNameStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ServiceName> {
  ServiceName _impl;

  _ServiceNameStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ServiceName.serviceName;


  Function _serviceNameServiceNameResponseParamsResponder(
      int requestId) {
  return (String serviceName_) {
      var result = new ServiceNameServiceNameResponseParams();
      result.serviceName_ = serviceName_;
      sendResponse(buildResponseWithId(
          result,
          _serviceNameMethodServiceNameName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        _impl.serviceName_(_serviceNameServiceNameResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ServiceName get impl => _impl;
  set impl(ServiceName d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameStubControl($superString)";
  }

  int get version => 0;
}

class ServiceNameStub
    extends bindings.Stub<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameStub.unbound([ServiceName impl])
      : super(new _ServiceNameStubControl.unbound(impl));

  ServiceNameStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromEndpoint(endpoint, impl));

  ServiceNameStub.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromHandle(handle, impl));

  static ServiceNameStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameStub"));
    return new ServiceNameStub.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    return impl.serviceName_(callback);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xdzVcbRxKfETjGNknwbpzgOCHEySbeOJbANrbiZB0ECIsFBA/JCX6bt8ogBqQw+shIZPGefOS4xxxz9DFHH3P0cY/+E3z00bfdbk01mi5Nz/TIo9EIo/fmNSO6Zrp/XV3VXR+tccX6jEE5BSX+npUjqMT1fj1llX+Q6z1yPYHvn0H5EsorqlWuQ3kI5RMon0M5GbPKWShLUP4G5VMoX0J5ZcgqN6F8BOVjKP8L5diwVWagPITydyg/IdclcuUfrKcLy+kHd0x919QbjXKtWmjqjWYjnpKsN9eqd4NcV13rzWsV3ZjXGnqe3Kar+5UWXYJcn7vTlfTiHq0/r9Ubyl1S95Z3/VW9Waptf19ultKVevPhht6o16oNXVFuEtovvemzpLHzNcMo03/Qds6Q65o7Xa3a1MrVRso0tYdrO9DDvwGtN1123zC0LUPn6T8j14QrfXp7V7fa9hf3ehSIXNPcLzZJva/INe1enzSAAriUzac3sqmVlGG0RsD6XAXe8KZfluQPVn+l9i/dLGp0sKCNf5Wiy+5XtnSTtU/+fRv6jm7q1aL1Psobn7rSZWtmRTMYA3vz78bRFzMz0xLjlNPNX8pFnXIgqXePXN+6128NKe0JcE5Gq24bemNeMwx9G25az7gt+RyLhqens/yOJP1StambO1oRPUJyvlPxcPQE5QqVka71v9PNpn5woFrymMppKlpLaltu0z9Hhnk5/viN9j0VmYcX+Ps/3ufvDz7ln/f7Nf7+8RT6/w3+fv0W//7/3ObvH33D3z+9y9+X5vj7Jwv8/csM397SCrrP8e3JPODvlR/4+8N/8vR1jf//i23QX0hPKoB7nek1hf8w/ZuE8n/wySjOnzPwyBTc02H5E7kE6kpx0venaf/J9SPlv/2GmTBqRc1I7NZqu4aeKNUqeuLfppao1H6qJRpm0fqjvr9llIuJMuPERmKrXN0uV3cbidYLEx0toGSVI35T+P4nbe06ZVsneH1E+Ck2/FrrAg/8tgTrmWloT1j4TPJsctSOcdReYHfp9QfGfdyGgWp7T1j8OufFr3PO43HzhF9b7dEE/DoTUX5NKf7W1bL8ivs/rrrjnEF8WhLgfJFc58nlvCpXlC/IddmJbwUEuJ27IY8Tfcc5ui9S0H4L5vVz2BeNw/4tA/r/4DSsB2Agnp2B/d85mAejsO9C8sMv/89KjguVFWep/FhbWynkM0vZe22+vyY1HnGOFI8LfW8sxHHxwk0NCLd3yEWHamHt/txKuo3cbVhzSuDGkWLcyhHDLRYQbn+GebO4spbK2xiOLlfjcrhxpBi3nyKG21DA85TsjpNdzlOOFOO2FzHchoPHbfpW17i1STFuRsRwOxXwPCWdv3GdcM20/3nKkWLcKhHD7Y3gcbt1s5AvTVd3u8CtTYpxq0YMt9MB43afSql8oRvcOFKMWy1iuI0EvA6535JSTdJ73+sQjhTjVo8Ybmd6gJslpSyG84nbESnG7eeI4Xa2B7hRKZXpjt+OSDFuZkRwG1O722dtCnCj5t436f6X8y61/S0ebqgOnO7CmIaF07jAHjFq21M52Rk68FVfzY4zK8D3Mti+cnrT1ZGE+/FtyPwmsgf+GpPHwc0eyOwoYhyumfrP+6RBzngotn3762wP1BUxv8z0gV8U1A7W/o8gLkDE9K/qd5W1G4rk6JSkHF1H/H0gGB/qFvuAyVGh191tf+dOiMf7bETk7JjNBqPC9zFbvd+G3OVtMhasvGV+Uophbb+5rplEz5OupqrbHKS4P+ciIm8VNRh5OwVYeOHApG6/5e2IxLy2708wfiMqX8rity7Aj8VbSODXntwR0Ft+cRTNy/UhObu0HU/VZV7SWI8PAU8hmA74jUZkXo4HtA5icS+uONiWQoOwDvLz6bUffxTw7Rc+fv3tQcn7OOzZvPiKTbSBl1PsXnIdJ+sPZnEKztGP7Xg/yXDJDpzfHtD9MdvnbA53N5+THv73VuRiJ9yO8cn91AdHcc1D/uatSC9+DBh09J/fDvd9vuJ1PY6/6Jc+eBts/RXSZG1Xd+SXiyHi1A0eqk88VBc8xmAOm4J9zhjEnUZBP8Zc9GPQ84zZ4ZzmmX0BfzLPuptn56HOyTxr4/HhAMwztn56Ggtm/XQJfKbOWSDtvALJtJEOPvs+gnGhMRf/QbfzcEpA/y653qJxoRSmQm2noBOgHPwwm+AT64c9mPaB2cdHRH4s9D2Lh+GzSvznoXS7H2P24GexYOzBLP7VPaupnYflMx2qY7z/cTIvpObFD+Dz7Efc9CDOi6DzAkYhhs7K1rN05AUn/ocKePw+U07yAmh7fhHsCz8P2b4widZW2M7wFsSwWdlpinQeW7f8yuIjxtRg4iNY/BefNdr293mkl3aMTzxk/vVrZ+tVnoWXP5j5q2TdwLidSSX8fJghG14ZwOlRzN1eKSsPkpK4sn1ILp/KLqQ2FphfXRbHOCMUjP9XymDnSdQFz2F6dfH+ykpufiOdzlrff61YOdPS+KEHYPzuKIOdLyHC7zzooqXV1fRGbum7tK2/1/3ghx6A8fs6ZPzw+0cC0iMML/40gLZdyuPYgA5cLocs77z8Axgvv/Jt3WO9s4zibMR4xZed8PokZD5i+eJKj/Uq8584nxrhkr8oIMDtvBgyn2H756wajD6dlcSTzdN1Q6tq5uI0HFcg3qd34BjnSDGe7yvHM+8Q4Xbjete4WaQYt0vHRA+8B3ZyfFoL2xd5HeuC2zURUT3A9l/DPvWACLc3oZ97heuFaVu8gxdecSDAuH3UJ30wHLI+4E/1kdAHiAC3850+64O66s53TF9M+IzrPfTwz+8VcmTdml4rkN0StVvMrZE9U2F1aR7q0f3TN1K4xl0fhfG+0Cc+nXCZ3zHb/J4IfH6vpjZt8atSeBISjNu7fY4TSXbJR92e19UrfSWyPzP/hofZuaNdG32WH1Nqb+wzXny9uLSRy0NM8cfuuMVZXSf8cgO2fpTFidmJc+n5teyCi56y4cTqOuGUV453vh5/mp5Lvh6qiHEqDGg84nPm5x4K1r9yDvTfPb3pyFc/9lmvsH4nfcajT3n4N0h/uYjDQYg7D9O/zPKL9/SHhbqp75QPrJMcnfij33EXdtzGHPwF3fjVniMD8qvyHcPT4rt2BN6g5DucCsnfy/Qiaeq+0XTmty+V6OU7hKUPmfziT4t1sROjihjP4oDqwxeMPhas3GP4NhC+uN3bfdaLL1ApK5+SHnGMtn5HSj++ar4kw2kyFgxeH4BM5/EaLLmuhrie8DOvLoWMUxDrBWaHO/Tgr01JOxzLm5Q75Vs5Oh+/y2PCO8ZhMaLxlWHFnbH4/xIAhPG5B3/3c9073IN1L7MXbQYUF8zyoN1PmXc5X8yDEI/LXAT5djhCfDsPfstBk69JdK6vLF8+EuDE/I9ev14gjC+T+9mDDvyzr3k8rxd/rvVRrioO/Mfsj/yvU/j/PYuo7SNF/RLaVVFFPG5/H/B9ZK/WuznS61XIIXSSB8vHdB9p6/ex2kcqKO5Z1g+U8bB3sXwBFjcuSBPowO8L5SQ/xO2cuKtKuHm6k8hPiPWJKL/C7+94yeqT/wcAAP//765mmwhvAAA=";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
