// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library regression_tests_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class EnumWithReference extends bindings.MojoEnum {
  static const EnumWithReference kStereoAndKeyboardMic = const EnumWithReference._(30);
  static const EnumWithReference kMax = const EnumWithReference._(30);

  const EnumWithReference._(int v) : super(v);

  static const Map<String, EnumWithReference> valuesMap = const {
    "kStereoAndKeyboardMic": kStereoAndKeyboardMic,
    "kMax": kMax,
  };
  static const List<EnumWithReference> values = const [
    kStereoAndKeyboardMic,
    kMax,
  ];

  static EnumWithReference valueOf(String name) => valuesMap[name];

  factory EnumWithReference(int v) {
    switch (v) {
      case 30:
        return EnumWithReference.kStereoAndKeyboardMic;
      case 30:
        return EnumWithReference.kMax;
      default:
        return null;
    }
  }

  static EnumWithReference decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithReference result = new EnumWithReference(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithReference.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case kStereoAndKeyboardMic:
        return 'EnumWithReference.kStereoAndKeyboardMic';
      case kMax:
        return 'EnumWithReference.kMax';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithLowercase extends bindings.MojoEnum {
  static const EnumWithLowercase planarF16 = const EnumWithLowercase._(0);
  static const EnumWithLowercase planarF32 = const EnumWithLowercase._(1);

  const EnumWithLowercase._(int v) : super(v);

  static const Map<String, EnumWithLowercase> valuesMap = const {
    "planarF16": planarF16,
    "planarF32": planarF32,
  };
  static const List<EnumWithLowercase> values = const [
    planarF16,
    planarF32,
  ];

  static EnumWithLowercase valueOf(String name) => valuesMap[name];

  factory EnumWithLowercase(int v) {
    switch (v) {
      case 0:
        return EnumWithLowercase.planarF16;
      case 1:
        return EnumWithLowercase.planarF32;
      default:
        return null;
    }
  }

  static EnumWithLowercase decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithLowercase result = new EnumWithLowercase(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithLowercase.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case planarF16:
        return 'EnumWithLowercase.planarF16';
      case planarF32:
        return 'EnumWithLowercase.planarF32';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithNumbers extends bindings.MojoEnum {
  static const EnumWithNumbers k21 = const EnumWithNumbers._(4);

  const EnumWithNumbers._(int v) : super(v);

  static const Map<String, EnumWithNumbers> valuesMap = const {
    "k21": k21,
  };
  static const List<EnumWithNumbers> values = const [
    k21,
  ];

  static EnumWithNumbers valueOf(String name) => valuesMap[name];

  factory EnumWithNumbers(int v) {
    switch (v) {
      case 4:
        return EnumWithNumbers.k21;
      default:
        return null;
    }
  }

  static EnumWithNumbers decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithNumbers result = new EnumWithNumbers(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithNumbers.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k21:
        return 'EnumWithNumbers.k21';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithK extends bindings.MojoEnum {
  static const EnumWithK k = const EnumWithK._(0);

  const EnumWithK._(int v) : super(v);

  static const Map<String, EnumWithK> valuesMap = const {
    "k": k,
  };
  static const List<EnumWithK> values = const [
    k,
  ];

  static EnumWithK valueOf(String name) => valuesMap[name];

  factory EnumWithK(int v) {
    switch (v) {
      case 0:
        return EnumWithK.k;
      default:
        return null;
    }
  }

  static EnumWithK decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithK result = new EnumWithK(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithK.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k:
        return 'EnumWithK.k';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithInternalAllCaps extends bindings.MojoEnum {
  static const EnumWithInternalAllCaps standard = const EnumWithInternalAllCaps._(0);
  static const EnumWithInternalAllCaps fullscreen = const EnumWithInternalAllCaps._(1);
  static const EnumWithInternalAllCaps immersive = const EnumWithInternalAllCaps._(2);

  const EnumWithInternalAllCaps._(int v) : super(v);

  static const Map<String, EnumWithInternalAllCaps> valuesMap = const {
    "standard": standard,
    "fullscreen": fullscreen,
    "immersive": immersive,
  };
  static const List<EnumWithInternalAllCaps> values = const [
    standard,
    fullscreen,
    immersive,
  ];

  static EnumWithInternalAllCaps valueOf(String name) => valuesMap[name];

  factory EnumWithInternalAllCaps(int v) {
    switch (v) {
      case 0:
        return EnumWithInternalAllCaps.standard;
      case 1:
        return EnumWithInternalAllCaps.fullscreen;
      case 2:
        return EnumWithInternalAllCaps.immersive;
      default:
        return null;
    }
  }

  static EnumWithInternalAllCaps decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithInternalAllCaps result = new EnumWithInternalAllCaps(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithInternalAllCaps.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case standard:
        return 'EnumWithInternalAllCaps.standard';
      case fullscreen:
        return 'EnumWithInternalAllCaps.fullscreen';
      case immersive:
        return 'EnumWithInternalAllCaps.immersive';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class NormalEnum extends bindings.MojoEnum {
  static const NormalEnum first = const NormalEnum._(0);
  static const NormalEnum second = const NormalEnum._(1);

  const NormalEnum._(int v) : super(v);

  static const Map<String, NormalEnum> valuesMap = const {
    "first": first,
    "second": second,
  };
  static const List<NormalEnum> values = const [
    first,
    second,
  ];

  static NormalEnum valueOf(String name) => valuesMap[name];

  factory NormalEnum(int v) {
    switch (v) {
      case 0:
        return NormalEnum.first;
      case 1:
        return NormalEnum.second;
      default:
        return null;
    }
  }

  static NormalEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    NormalEnum result = new NormalEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum NormalEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case first:
        return 'NormalEnum.first';
      case second:
        return 'NormalEnum.second';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class CamelCaseTestEnum extends bindings.MojoEnum {
  static const CamelCaseTestEnum boolThing = const CamelCaseTestEnum._(0);
  static const CamelCaseTestEnum doubleThing = const CamelCaseTestEnum._(1);
  static const CamelCaseTestEnum floatThing = const CamelCaseTestEnum._(2);
  static const CamelCaseTestEnum int8Thing = const CamelCaseTestEnum._(3);
  static const CamelCaseTestEnum int16Thing = const CamelCaseTestEnum._(4);
  static const CamelCaseTestEnum int32Th1Ng = const CamelCaseTestEnum._(5);
  static const CamelCaseTestEnum int64Th1ng = const CamelCaseTestEnum._(6);
  static const CamelCaseTestEnum uint8TH1ng = const CamelCaseTestEnum._(7);
  static const CamelCaseTestEnum uint16tH1Ng = const CamelCaseTestEnum._(8);
  static const CamelCaseTestEnum uint32Th1ng = const CamelCaseTestEnum._(9);
  static const CamelCaseTestEnum uint64Th1Ng = const CamelCaseTestEnum._(10);

  const CamelCaseTestEnum._(int v) : super(v);

  static const Map<String, CamelCaseTestEnum> valuesMap = const {
    "boolThing": boolThing,
    "doubleThing": doubleThing,
    "floatThing": floatThing,
    "int8Thing": int8Thing,
    "int16Thing": int16Thing,
    "int32Th1Ng": int32Th1Ng,
    "int64Th1ng": int64Th1ng,
    "uint8TH1ng": uint8TH1ng,
    "uint16tH1Ng": uint16tH1Ng,
    "uint32Th1ng": uint32Th1ng,
    "uint64Th1Ng": uint64Th1Ng,
  };
  static const List<CamelCaseTestEnum> values = const [
    boolThing,
    doubleThing,
    floatThing,
    int8Thing,
    int16Thing,
    int32Th1Ng,
    int64Th1ng,
    uint8TH1ng,
    uint16tH1Ng,
    uint32Th1ng,
    uint64Th1Ng,
  ];

  static CamelCaseTestEnum valueOf(String name) => valuesMap[name];

  factory CamelCaseTestEnum(int v) {
    switch (v) {
      case 0:
        return CamelCaseTestEnum.boolThing;
      case 1:
        return CamelCaseTestEnum.doubleThing;
      case 2:
        return CamelCaseTestEnum.floatThing;
      case 3:
        return CamelCaseTestEnum.int8Thing;
      case 4:
        return CamelCaseTestEnum.int16Thing;
      case 5:
        return CamelCaseTestEnum.int32Th1Ng;
      case 6:
        return CamelCaseTestEnum.int64Th1ng;
      case 7:
        return CamelCaseTestEnum.uint8TH1ng;
      case 8:
        return CamelCaseTestEnum.uint16tH1Ng;
      case 9:
        return CamelCaseTestEnum.uint32Th1ng;
      case 10:
        return CamelCaseTestEnum.uint64Th1Ng;
      default:
        return null;
    }
  }

  static CamelCaseTestEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    CamelCaseTestEnum result = new CamelCaseTestEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum CamelCaseTestEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case boolThing:
        return 'CamelCaseTestEnum.boolThing';
      case doubleThing:
        return 'CamelCaseTestEnum.doubleThing';
      case floatThing:
        return 'CamelCaseTestEnum.floatThing';
      case int8Thing:
        return 'CamelCaseTestEnum.int8Thing';
      case int16Thing:
        return 'CamelCaseTestEnum.int16Thing';
      case int32Th1Ng:
        return 'CamelCaseTestEnum.int32Th1Ng';
      case int64Th1ng:
        return 'CamelCaseTestEnum.int64Th1ng';
      case uint8TH1ng:
        return 'CamelCaseTestEnum.uint8TH1ng';
      case uint16tH1Ng:
        return 'CamelCaseTestEnum.uint16tH1Ng';
      case uint32Th1ng:
        return 'CamelCaseTestEnum.uint32Th1ng';
      case uint64Th1Ng:
        return 'CamelCaseTestEnum.uint64Th1Ng';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class Edge extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Vertex v = null;

  Edge() : super(kVersions.last.size);

  Edge.init(
    Vertex this.v
  ) : super(kVersions.last.size);

  static Edge deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Edge decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Edge result = new Edge();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.v = Vertex.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Edge";
    String fieldName;
    try {
      fieldName = "v";
      encoder0.encodeStruct(v, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Edge("
           "v: $v" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["v"] = v;
    return map;
  }
}


class Vertex extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EmptyStruct e = null;

  Vertex() : super(kVersions.last.size);

  Vertex.init(
    EmptyStruct this.e
  ) : super(kVersions.last.size);

  static Vertex deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Vertex decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Vertex result = new Vertex();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.e = EmptyStruct.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Vertex";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeStruct(e, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Vertex("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class EmptyStruct extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  EmptyStruct() : super(kVersions.last.size);

  EmptyStruct.init(
  ) : super(kVersions.last.size);

  static EmptyStruct deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EmptyStruct decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EmptyStruct result = new EmptyStruct();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EmptyStruct";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EmptyStruct("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class A extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  B b = null;

  A() : super(kVersions.last.size);

  A.init(
    B this.b
  ) : super(kVersions.last.size);

  static A deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static A decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    A result = new A();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.b = B.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "A";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeStruct(b, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "A("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class B extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  A a = null;

  B() : super(kVersions.last.size);

  B.init(
    A this.a
  ) : super(kVersions.last.size);

  static B deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static B decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    B result = new B();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.a = A.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "B";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeStruct(a, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "B("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class StructWithHandleCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoHandle handles = null;

  StructWithHandleCalledHandles() : super(kVersions.last.size);

  StructWithHandleCalledHandles.init(
    core.MojoHandle this.handles
  ) : super(kVersions.last.size);

  static StructWithHandleCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHandleCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHandleCalledHandles result = new StructWithHandleCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHandleCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandle(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHandleCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithArrayOfHandlesCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<core.MojoHandle> handles = null;

  StructWithArrayOfHandlesCalledHandles() : super(kVersions.last.size);

  StructWithArrayOfHandlesCalledHandles.init(
    List<core.MojoHandle> this.handles
  ) : super(kVersions.last.size);

  static StructWithArrayOfHandlesCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithArrayOfHandlesCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithArrayOfHandlesCalledHandles result = new StructWithArrayOfHandlesCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithArrayOfHandlesCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandleArray(handles, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithArrayOfHandlesCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithInterfaceCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  TestInterfaceInterface handles = null;

  StructWithInterfaceCalledHandles() : super(kVersions.last.size);

  StructWithInterfaceCalledHandles.init(
    TestInterfaceInterface this.handles
  ) : super(kVersions.last.size);

  static StructWithInterfaceCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterfaceCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterfaceCalledHandles result = new StructWithInterfaceCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeServiceInterface(8, false, TestInterfaceProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterfaceCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeInterface(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterfaceCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ContainsArrayOfEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<NormalEnum> arrayOfEnums = null;

  ContainsArrayOfEnum() : super(kVersions.last.size);

  ContainsArrayOfEnum.init(
    List<NormalEnum> this.arrayOfEnums
  ) : super(kVersions.last.size);

  static ContainsArrayOfEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ContainsArrayOfEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ContainsArrayOfEnum result = new ContainsArrayOfEnum();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForEnumArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfEnums = new List<NormalEnum>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.arrayOfEnums[i1] = NormalEnum.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i1);
            if (result.arrayOfEnums[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable NormalEnum.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ContainsArrayOfEnum";
    String fieldName;
    try {
      fieldName = "arrayOfEnums";
      if (arrayOfEnums == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodeEnumArray(arrayOfEnums.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < arrayOfEnums.length; ++i0) {
          encoder1.encodeEnum(arrayOfEnums[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i0);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ContainsArrayOfEnum("
           "arrayOfEnums: $arrayOfEnums" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["arrayOfEnums"] = arrayOfEnums;
    return map;
  }
}


class ContainsNullableArrayOfEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<NormalEnum> arrayOfEnums = null;

  ContainsNullableArrayOfEnum() : super(kVersions.last.size);

  ContainsNullableArrayOfEnum.init(
    List<NormalEnum> this.arrayOfEnums
  ) : super(kVersions.last.size);

  static ContainsNullableArrayOfEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ContainsNullableArrayOfEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ContainsNullableArrayOfEnum result = new ContainsNullableArrayOfEnum();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      if (decoder1 == null) {
        result.arrayOfEnums = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForEnumArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfEnums = new List<NormalEnum>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.arrayOfEnums[i1] = NormalEnum.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i1);
            if (result.arrayOfEnums[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable NormalEnum.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ContainsNullableArrayOfEnum";
    String fieldName;
    try {
      fieldName = "arrayOfEnums";
      if (arrayOfEnums == null) {
        encoder0.encodeNullPointer(8, true);
      } else {
        var encoder1 = encoder0.encodeEnumArray(arrayOfEnums.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < arrayOfEnums.length; ++i0) {
          encoder1.encodeEnum(arrayOfEnums[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i0);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ContainsNullableArrayOfEnum("
           "arrayOfEnums: $arrayOfEnums" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["arrayOfEnums"] = arrayOfEnums;
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams.init(
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool b = false;

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.init(
    bool this.b
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeBool(b, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckNameCollisionWithNameCollisionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  _CheckNameCollisionWithNameCollisionParams() : super(kVersions.last.size);

  _CheckNameCollisionWithNameCollisionParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static _CheckNameCollisionWithNameCollisionParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckNameCollisionWithNameCollisionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckNameCollisionWithNameCollisionParams result = new _CheckNameCollisionWithNameCollisionParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckNameCollisionWithNameCollisionParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckNameCollisionWithNameCollisionParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class CheckNameCollisionWithNameCollisionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  CheckNameCollisionWithNameCollisionResponseParams() : super(kVersions.last.size);

  CheckNameCollisionWithNameCollisionResponseParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static CheckNameCollisionWithNameCollisionResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckNameCollisionWithNameCollisionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckNameCollisionWithNameCollisionResponseParams result = new CheckNameCollisionWithNameCollisionResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckNameCollisionWithNameCollisionResponseParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckNameCollisionWithNameCollisionResponseParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class _CheckEnumCapsSetEnumWithInternalAllCapsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EnumWithInternalAllCaps e = null;

  _CheckEnumCapsSetEnumWithInternalAllCapsParams() : super(kVersions.last.size);

  _CheckEnumCapsSetEnumWithInternalAllCapsParams.init(
    EnumWithInternalAllCaps this.e
  ) : super(kVersions.last.size);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckEnumCapsSetEnumWithInternalAllCapsParams result = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.e = EnumWithInternalAllCaps.decode(decoder0, 8);
        if (result.e == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable EnumWithInternalAllCaps.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckEnumCapsSetEnumWithInternalAllCapsParams";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeEnum(e, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckEnumCapsSetEnumWithInternalAllCapsParams("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class _TestInterfaceSomeMessageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestInterfaceSomeMessageParams() : super(kVersions.last.size);

  _TestInterfaceSomeMessageParams.init(
  ) : super(kVersions.last.size);

  static _TestInterfaceSomeMessageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestInterfaceSomeMessageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestInterfaceSomeMessageParams result = new _TestInterfaceSomeMessageParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestInterfaceSomeMessageParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestInterfaceSomeMessageParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _Regression551GetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<String> keyPrefixes = null;

  _Regression551GetParams() : super(kVersions.last.size);

  _Regression551GetParams.init(
    List<String> this.keyPrefixes
  ) : super(kVersions.last.size);

  static _Regression551GetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _Regression551GetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _Regression551GetParams result = new _Regression551GetParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.keyPrefixes = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.keyPrefixes[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_Regression551GetParams";
    String fieldName;
    try {
      fieldName = "keyPrefixes";
      if (keyPrefixes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(keyPrefixes.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < keyPrefixes.length; ++i0) {
          encoder1.encodeString(keyPrefixes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_Regression551GetParams("
           "keyPrefixes: $keyPrefixes" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["keyPrefixes"] = keyPrefixes;
    return map;
  }
}


class Regression551GetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int result = 0;

  Regression551GetResponseParams() : super(kVersions.last.size);

  Regression551GetResponseParams.init(
    int this.result
  ) : super(kVersions.last.size);

  static Regression551GetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Regression551GetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Regression551GetResponseParams result = new Regression551GetResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.result = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Regression551GetResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeInt32(result, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Regression551GetResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _ServiceNameServiceNameParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _ServiceNameServiceNameParams() : super(kVersions.last.size);

  _ServiceNameServiceNameParams.init(
  ) : super(kVersions.last.size);

  static _ServiceNameServiceNameParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ServiceNameServiceNameParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ServiceNameServiceNameParams result = new _ServiceNameServiceNameParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ServiceNameServiceNameParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ServiceNameServiceNameParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class ServiceNameServiceNameResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String serviceName_ = null;

  ServiceNameServiceNameResponseParams() : super(kVersions.last.size);

  ServiceNameServiceNameResponseParams.init(
    String this.serviceName_
  ) : super(kVersions.last.size);

  static ServiceNameServiceNameResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceNameServiceNameResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceNameServiceNameResponseParams result = new ServiceNameServiceNameResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.serviceName_ = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceNameServiceNameResponseParams";
    String fieldName;
    try {
      fieldName = "serviceName_";
      encoder0.encodeString(serviceName_, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceNameServiceNameResponseParams("
           "serviceName_: $serviceName_" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["serviceName_"] = serviceName_;
    return map;
  }
}

const int _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName = 0;
const int _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName = 1;

class _CheckMethodWithEmptyResponseServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckMethodWithEmptyResponse {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckMethodWithEmptyResponseServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckMethodWithEmptyResponseProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckMethodWithEmptyResponseProxy p = new CheckMethodWithEmptyResponseProxy.unbound();
    String name = serviceName ?? CheckMethodWithEmptyResponse.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withoutParameterAndEmptyResponse(void callback());
  void withParameterAndEmptyResponse(bool b,void callback());
}

abstract class CheckMethodWithEmptyResponseInterface
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterface([CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.unbound(impl);

  factory CheckMethodWithEmptyResponseInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint, impl);

  factory CheckMethodWithEmptyResponseInterface.fromMock(
      CheckMethodWithEmptyResponse mock) =>
      new CheckMethodWithEmptyResponseProxy.fromMock(mock);
}

abstract class CheckMethodWithEmptyResponseInterfaceRequest
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterfaceRequest() =>
      new CheckMethodWithEmptyResponseProxy.unbound();
}

class _CheckMethodWithEmptyResponseProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse impl;

  _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckMethodWithEmptyResponseProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckMethodWithEmptyResponseProxyControl.unbound() : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseProxyControl($superString)";
  }
}

class CheckMethodWithEmptyResponseProxy
    extends bindings.Proxy<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(endpoint));

  CheckMethodWithEmptyResponseProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromHandle(handle));

  CheckMethodWithEmptyResponseProxy.unbound()
      : super(new _CheckMethodWithEmptyResponseProxyControl.unbound());

  factory CheckMethodWithEmptyResponseProxy.fromMock(CheckMethodWithEmptyResponse mock) {
    CheckMethodWithEmptyResponseProxy newMockedProxy =
        new CheckMethodWithEmptyResponseProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckMethodWithEmptyResponseProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseProxy"));
    return new CheckMethodWithEmptyResponseProxy.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    if (impl != null) {
      impl.withoutParameterAndEmptyResponse(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    if (impl != null) {
      impl.withParameterAndEmptyResponse(b,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();
    params.b = b;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckMethodWithEmptyResponseStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse _impl;

  _CheckMethodWithEmptyResponseStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;


  Function _checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        _impl.withoutParameterAndEmptyResponse(_checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        var params = _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.deserialize(
            message.payload);
        _impl.withParameterAndEmptyResponse(params.b, _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckMethodWithEmptyResponse get impl => _impl;
  set impl(CheckMethodWithEmptyResponse d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseStubControl($superString)";
  }

  int get version => 0;
}

class CheckMethodWithEmptyResponseStub
    extends bindings.Stub<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseStub.unbound([CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.unbound(impl));

  CheckMethodWithEmptyResponseStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromEndpoint(endpoint, impl));

  CheckMethodWithEmptyResponseStub.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromHandle(handle, impl));

  static CheckMethodWithEmptyResponseStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseStub"));
    return new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    return impl.withoutParameterAndEmptyResponse(callback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    return impl.withParameterAndEmptyResponse(b,callback);
  }
}

const int _checkNameCollisionMethodWithNameCollisionName = 0;

class _CheckNameCollisionServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckNameCollision {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckNameCollisionServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckNameCollisionProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckNameCollisionProxy p = new CheckNameCollisionProxy.unbound();
    String name = serviceName ?? CheckNameCollision.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withNameCollision(bool message,bool response,void callback(bool message, bool response));
}

abstract class CheckNameCollisionInterface
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterface([CheckNameCollision impl]) =>
      new CheckNameCollisionStub.unbound(impl);

  factory CheckNameCollisionInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckNameCollision impl]) =>
      new CheckNameCollisionStub.fromEndpoint(endpoint, impl);

  factory CheckNameCollisionInterface.fromMock(
      CheckNameCollision mock) =>
      new CheckNameCollisionProxy.fromMock(mock);
}

abstract class CheckNameCollisionInterfaceRequest
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterfaceRequest() =>
      new CheckNameCollisionProxy.unbound();
}

class _CheckNameCollisionProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckNameCollision> {
  CheckNameCollision impl;

  _CheckNameCollisionProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckNameCollisionProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckNameCollisionProxyControl.unbound() : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = CheckNameCollisionWithNameCollisionResponseParams.deserialize(
              message.payload);
          callback(r.message , r.response );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionProxyControl($superString)";
  }
}

class CheckNameCollisionProxy
    extends bindings.Proxy<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckNameCollisionProxyControl.fromEndpoint(endpoint));

  CheckNameCollisionProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckNameCollisionProxyControl.fromHandle(handle));

  CheckNameCollisionProxy.unbound()
      : super(new _CheckNameCollisionProxyControl.unbound());

  factory CheckNameCollisionProxy.fromMock(CheckNameCollision mock) {
    CheckNameCollisionProxy newMockedProxy =
        new CheckNameCollisionProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckNameCollisionProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionProxy"));
    return new CheckNameCollisionProxy.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    if (impl != null) {
      impl.withNameCollision(message,response,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _CheckNameCollisionWithNameCollisionParams();
    params.message = message;
    params.response = response;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((bool message, bool response) {
        z.bindCallback(() {
          callback(message, response);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkNameCollisionMethodWithNameCollisionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckNameCollisionStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckNameCollision> {
  CheckNameCollision _impl;

  _CheckNameCollisionStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;


  Function _checkNameCollisionWithNameCollisionResponseParamsResponder(
      int requestId) {
  return (bool message, bool response) {
      var result = new CheckNameCollisionWithNameCollisionResponseParams();
      result.message = message;
      result.response = response;
      sendResponse(buildResponseWithId(
          result,
          _checkNameCollisionMethodWithNameCollisionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        var params = _CheckNameCollisionWithNameCollisionParams.deserialize(
            message.payload);
        _impl.withNameCollision(params.message, params.response, _checkNameCollisionWithNameCollisionResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckNameCollision get impl => _impl;
  set impl(CheckNameCollision d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionStubControl($superString)";
  }

  int get version => 0;
}

class CheckNameCollisionStub
    extends bindings.Stub<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionStub.unbound([CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.unbound(impl));

  CheckNameCollisionStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromEndpoint(endpoint, impl));

  CheckNameCollisionStub.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromHandle(handle, impl));

  static CheckNameCollisionStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionStub"));
    return new CheckNameCollisionStub.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    return impl.withNameCollision(message,response,callback);
  }
}

const int _checkEnumCapsMethodSetEnumWithInternalAllCapsName = 0;

class _CheckEnumCapsServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckEnumCaps {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckEnumCapsServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckEnumCapsProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckEnumCapsProxy p = new CheckEnumCapsProxy.unbound();
    String name = serviceName ?? CheckEnumCaps.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e);
}

abstract class CheckEnumCapsInterface
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterface([CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.unbound(impl);

  factory CheckEnumCapsInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.fromEndpoint(endpoint, impl);

  factory CheckEnumCapsInterface.fromMock(
      CheckEnumCaps mock) =>
      new CheckEnumCapsProxy.fromMock(mock);
}

abstract class CheckEnumCapsInterfaceRequest
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterfaceRequest() =>
      new CheckEnumCapsProxy.unbound();
}

class _CheckEnumCapsProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckEnumCaps> {
  CheckEnumCaps impl;

  _CheckEnumCapsProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckEnumCapsProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckEnumCapsProxyControl.unbound() : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsProxyControl($superString)";
  }
}

class CheckEnumCapsProxy
    extends bindings.Proxy<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckEnumCapsProxyControl.fromEndpoint(endpoint));

  CheckEnumCapsProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckEnumCapsProxyControl.fromHandle(handle));

  CheckEnumCapsProxy.unbound()
      : super(new _CheckEnumCapsProxyControl.unbound());

  factory CheckEnumCapsProxy.fromMock(CheckEnumCaps mock) {
    CheckEnumCapsProxy newMockedProxy =
        new CheckEnumCapsProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckEnumCapsProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsProxy"));
    return new CheckEnumCapsProxy.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    if (impl != null) {
      impl.setEnumWithInternalAllCaps(e);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();
    params.e = e;
    ctrl.sendMessage(params,
        _checkEnumCapsMethodSetEnumWithInternalAllCapsName);
  }
}

class _CheckEnumCapsStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckEnumCaps> {
  CheckEnumCaps _impl;

  _CheckEnumCapsStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkEnumCapsMethodSetEnumWithInternalAllCapsName:
        var params = _CheckEnumCapsSetEnumWithInternalAllCapsParams.deserialize(
            message.payload);
        _impl.setEnumWithInternalAllCaps(params.e);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckEnumCaps get impl => _impl;
  set impl(CheckEnumCaps d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsStubControl($superString)";
  }

  int get version => 0;
}

class CheckEnumCapsStub
    extends bindings.Stub<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsStub.unbound([CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.unbound(impl));

  CheckEnumCapsStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromEndpoint(endpoint, impl));

  CheckEnumCapsStub.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromHandle(handle, impl));

  static CheckEnumCapsStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsStub"));
    return new CheckEnumCapsStub.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    return impl.setEnumWithInternalAllCaps(e);
  }
}

const int _testInterfaceMethodSomeMessageName = 0;

class _TestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestInterfaceProxy p = new TestInterfaceProxy.unbound();
    String name = serviceName ?? TestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void someMessage();
}

abstract class TestInterfaceInterface
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterface([TestInterface impl]) =>
      new TestInterfaceStub.unbound(impl);

  factory TestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestInterface impl]) =>
      new TestInterfaceStub.fromEndpoint(endpoint, impl);

  factory TestInterfaceInterface.fromMock(
      TestInterface mock) =>
      new TestInterfaceProxy.fromMock(mock);
}

abstract class TestInterfaceInterfaceRequest
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterfaceRequest() =>
      new TestInterfaceProxy.unbound();
}

class _TestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestInterface> {
  TestInterface impl;

  _TestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => TestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceProxyControl($superString)";
  }
}

class TestInterfaceProxy
    extends bindings.Proxy<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestInterfaceProxyControl.fromEndpoint(endpoint));

  TestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestInterfaceProxyControl.fromHandle(handle));

  TestInterfaceProxy.unbound()
      : super(new _TestInterfaceProxyControl.unbound());

  factory TestInterfaceProxy.fromMock(TestInterface mock) {
    TestInterfaceProxy newMockedProxy =
        new TestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceProxy"));
    return new TestInterfaceProxy.fromEndpoint(endpoint);
  }


  void someMessage() {
    if (impl != null) {
      impl.someMessage();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestInterfaceSomeMessageParams();
    ctrl.sendMessage(params,
        _testInterfaceMethodSomeMessageName);
  }
}

class _TestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestInterface> {
  TestInterface _impl;

  _TestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestInterface.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testInterfaceMethodSomeMessageName:
        _impl.someMessage();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestInterface get impl => _impl;
  set impl(TestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class TestInterfaceStub
    extends bindings.Stub<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceStub.unbound([TestInterface impl])
      : super(new _TestInterfaceStubControl.unbound(impl));

  TestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromEndpoint(endpoint, impl));

  TestInterfaceStub.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromHandle(handle, impl));

  static TestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceStub"));
    return new TestInterfaceStub.fromEndpoint(endpoint);
  }


  void someMessage() {
    return impl.someMessage();
  }
}

const int _regression551MethodGetName = 0;

class _Regression551ServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Regression551 {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _Regression551ServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static Regression551Proxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    Regression551Proxy p = new Regression551Proxy.unbound();
    String name = serviceName ?? Regression551.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void get(List<String> keyPrefixes,void callback(int result));
}

abstract class Regression551Interface
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551Interface([Regression551 impl]) =>
      new Regression551Stub.unbound(impl);

  factory Regression551Interface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Regression551 impl]) =>
      new Regression551Stub.fromEndpoint(endpoint, impl);

  factory Regression551Interface.fromMock(
      Regression551 mock) =>
      new Regression551Proxy.fromMock(mock);
}

abstract class Regression551InterfaceRequest
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551InterfaceRequest() =>
      new Regression551Proxy.unbound();
}

class _Regression551ProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Regression551> {
  Regression551 impl;

  _Regression551ProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _Regression551ProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _Regression551ProxyControl.unbound() : super.unbound();

  String get serviceName => Regression551.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _regression551MethodGetName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = Regression551GetResponseParams.deserialize(
              message.payload);
          callback(r.result );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551ProxyControl($superString)";
  }
}

class Regression551Proxy
    extends bindings.Proxy<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Proxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _Regression551ProxyControl.fromEndpoint(endpoint));

  Regression551Proxy.fromHandle(core.MojoHandle handle)
      : super(new _Regression551ProxyControl.fromHandle(handle));

  Regression551Proxy.unbound()
      : super(new _Regression551ProxyControl.unbound());

  factory Regression551Proxy.fromMock(Regression551 mock) {
    Regression551Proxy newMockedProxy =
        new Regression551Proxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static Regression551Proxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Proxy"));
    return new Regression551Proxy.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    if (impl != null) {
      impl.get(keyPrefixes,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _Regression551GetParams();
    params.keyPrefixes = keyPrefixes;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _regression551MethodGetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _Regression551StubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Regression551> {
  Regression551 _impl;

  _Regression551StubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Regression551.serviceName;


  Function _regression551GetResponseParamsResponder(
      int requestId) {
  return (int result) {
      var result = new Regression551GetResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _regression551MethodGetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _regression551MethodGetName:
        var params = _Regression551GetParams.deserialize(
            message.payload);
        _impl.get(params.keyPrefixes, _regression551GetResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Regression551 get impl => _impl;
  set impl(Regression551 d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551StubControl($superString)";
  }

  int get version => 0;
}

class Regression551Stub
    extends bindings.Stub<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Stub.unbound([Regression551 impl])
      : super(new _Regression551StubControl.unbound(impl));

  Regression551Stub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super(new _Regression551StubControl.fromEndpoint(endpoint, impl));

  Regression551Stub.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super(new _Regression551StubControl.fromHandle(handle, impl));

  static Regression551Stub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Stub"));
    return new Regression551Stub.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    return impl.get(keyPrefixes,callback);
  }
}

const int _serviceNameMethodServiceNameName = 0;

class _ServiceNameServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ServiceName {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ServiceNameServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ServiceNameProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ServiceNameProxy p = new ServiceNameProxy.unbound();
    String name = serviceName ?? ServiceName.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void serviceName_(void callback(String serviceName_));
}

abstract class ServiceNameInterface
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterface([ServiceName impl]) =>
      new ServiceNameStub.unbound(impl);

  factory ServiceNameInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ServiceName impl]) =>
      new ServiceNameStub.fromEndpoint(endpoint, impl);

  factory ServiceNameInterface.fromMock(
      ServiceName mock) =>
      new ServiceNameProxy.fromMock(mock);
}

abstract class ServiceNameInterfaceRequest
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterfaceRequest() =>
      new ServiceNameProxy.unbound();
}

class _ServiceNameProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ServiceName> {
  ServiceName impl;

  _ServiceNameProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ServiceNameProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ServiceNameProxyControl.unbound() : super.unbound();

  String get serviceName => ServiceName.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = ServiceNameServiceNameResponseParams.deserialize(
              message.payload);
          callback(r.serviceName_ );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameProxyControl($superString)";
  }
}

class ServiceNameProxy
    extends bindings.Proxy<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ServiceNameProxyControl.fromEndpoint(endpoint));

  ServiceNameProxy.fromHandle(core.MojoHandle handle)
      : super(new _ServiceNameProxyControl.fromHandle(handle));

  ServiceNameProxy.unbound()
      : super(new _ServiceNameProxyControl.unbound());

  factory ServiceNameProxy.fromMock(ServiceName mock) {
    ServiceNameProxy newMockedProxy =
        new ServiceNameProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ServiceNameProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameProxy"));
    return new ServiceNameProxy.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    if (impl != null) {
      impl.serviceName_(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _ServiceNameServiceNameParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String serviceName_) {
        z.bindCallback(() {
          callback(serviceName_);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _serviceNameMethodServiceNameName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _ServiceNameStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ServiceName> {
  ServiceName _impl;

  _ServiceNameStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ServiceName.serviceName;


  Function _serviceNameServiceNameResponseParamsResponder(
      int requestId) {
  return (String serviceName_) {
      var result = new ServiceNameServiceNameResponseParams();
      result.serviceName_ = serviceName_;
      sendResponse(buildResponseWithId(
          result,
          _serviceNameMethodServiceNameName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        _impl.serviceName_(_serviceNameServiceNameResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ServiceName get impl => _impl;
  set impl(ServiceName d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameStubControl($superString)";
  }

  int get version => 0;
}

class ServiceNameStub
    extends bindings.Stub<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameStub.unbound([ServiceName impl])
      : super(new _ServiceNameStubControl.unbound(impl));

  ServiceNameStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromEndpoint(endpoint, impl));

  ServiceNameStub.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromHandle(handle, impl));

  static ServiceNameStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameStub"));
    return new ServiceNameStub.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    return impl.serviceName_(callback);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xdP3gbRRaflR1ikgDOHQEHgzHhIDlCJNuJExEOsGzLkbEt+7NkMB/3nSLLa0t49YeVzDlXpUxJSUmZ8sqUlJSUKSlTUqa7m9G+sXaednZnlbV3Zazvm2+88jxp5jfvz8yb90YjxHoNQz0BNX6f10Ooxu1+OmPVv9DyJi1P4P2nUD+H+ppm1WtQP4L6CdTPoB6PWfUM1GWof4b6V6ifQ31twKo3oX4I9WOof4N6eNCqM1A/gvq/UL9Pyygt+W/W0oWl9Dd3TX3X1JvNSr1WaOnNVjOeUmw32253k5brru3milXdmCs29Tx9TNf2q226BC1X3enKemmPtZ8rNprkc9r2tnf7Fb1Vrm9/XWmV09VG68G63mzUa02dkFuU9mNv+izt7FzdMCrsH6yf07TccKer11rFSq2ZMs3ig9UdGOFnQOtNl903jOKWoYv0H9Iy5kqf3t7Vrb594N6OAZFrmfulFm33CS2T7u1pBxiAi9l8ej2bWk4ZRnsGrNd14A1v+iVF/uDtl+v/1s1SkU0W9PHvSnTZ/eqWbvL+qX/fur6jm3qtZH0f442/udJl62a1aHAG9ubf9cM3pqcnFeYpp5s/VEo640Da7h4tX7i3b08pGwlwTqZY2zb05lzRMPRteGh/xh3Fz7FoRHom5XcV6RdrLd3cKZbQRyjKO1MPh59ArjEd6dr+K91s6QcHmqWPmZ5mqrWsdfQ2+3NkUNTjv77UeWYqc+gN8fn+qPi8+YH4eb/Fxeenk+LzH7fE55/viN//LCk+P/9MfF6bQXZpXnwuL4jPv3wp9jeTFZ8PNsT+PPxWfM78S3z+/b5I/7Qk/r+xC/YL2ckhwP0ht2tEfHH7C8Mn/4NXhji/XobvS8HzW7T8hRaJuSJO9v4sLRVaioz/9ptmwqiXikZit17fNfREuV7VE/8xi4lq/bv6VKJpltp/JRr7W0allKhwVmwmtiq17Uptt5lof2OiqwuMrEpEnPg6YgaNm/2/vZTQiNJLhiOx4dheH3jguCVZ10xCf44bJ84/GurPCOr3LCG+1iMY/xEbFprte46Lf2e9+HfWeV5unfKvgGNRwr/TEeffFPG37lblX4zDuOaOdwbxbVmC92VaLtLivGon5CNarjjxsYQA93M3pPliZu08s+fw/KMm7rMIrBOSsM9rwDrh8Vmr/h0mZOQc2OnzsL+6APszxBd+5WFGcX6YDmFdmF1dXS7kM4vZex05uKE0L3GBFM8P+95YCPPjhZ8WEH6v08KmbH51Y3Y53UHwDqxRFfATSDF+lYjiFwsIv7+CHC0sr6byNgZke/O4Gn4CKcbvu4jiNxCw/NLddbJH+RVIMX57EcVvMHj8Jm/3jF+HFONnRBS/MwHLLwXh5hTlokn/8iuQYvyqEcXvpeDxu32rkC9P1nZ7wK9DivGrRRS/swHjt8G0WL7QC34CKcavHlH8hgJev2y0tViLouB7/SKQYvwaEcXv5SPAz9JiFgP6xO+QFOP3fUTxO3cE+DEtlumN/w5JMX5mxPAb0Xrbv21K8LtEyytsfy2cbnXOezyOwbrw+hzm9rjxGpH4PS4g1xD2Z2Cch7QX8xvNSHC+Aj63nN5yPdDC4/giJP6T+SMfx9TxcPNHcr+NHI8bpv79Pu2XMy7Etr899UcSohM5/0yHyD8E9YeP412IW5AJw4ueC6v6LWV6NqmoZ9cQvx9I5omd5b7N9aw0KsBt3+hOiOf9XMT08LDN56PB+zFbuycD7vo4EwtWH/PzXIZlfb+1VjTpuoCOOFXbFqDF4zkfMX08pAWjjycAEy88uFaOij4eUpB3ezuM47Am1qo4rklw5HEiCjh2hD5C9s0vnjJ5LQ+o+cntuGou8srCHt4BXKWgOuB4IWLyei2g9ROP33HFw7aE6qf1k5/XUccjXACcw8bJb9xAUHYhDntBLz7jAnhS9BhB8bNe/KZ6ns3jLpyjOzvxjIrhoF14v9bn+2/e+GCwNzlPesQRtCM0u2F3jMOOgt3geMwM+JNnmR19D7DowkHcbkdGjvE+AceVhGU3XoMziCrteXFXd+SfyyHg1Qsumk9cNBdchkG2Tcn+idVXI2ZPYy72NGj5435AJ/mzbwhO5e/F5O8itDmVv25c3ukj+ePrr6exYNZfo3Dm65wl08m7UEyr6eK7ryMcJxtzOd/oVT4nJPQsjeFVhgGDq1DfKegUMIfzok04wwvTP83Gwv32Qx7+63EU9yNm4fjP2+l1n8f9089iwfineTywexZYJ2/NZ/pY17x/eyonvuTkn3BWG2ZceT/KSdB5FBcgdtDKdrRs6SUneYAGeB4/JKd5FHa/2w+S/ebVkPwY42hNhv0Zr0LsnpXtR5TzAnvlXx7vMaIFE+/B493ELNzO+aRHum7XPMVD4me//r2jyk/xOsfm52qqx9e4n0kSXj7RgA03fn/AjzG1+C4vPZFUxJfvZ3L5VHY+tT7P4wJU8YxzQgkffEJORn5JQ/I53P4ubCwv5+bW02nIx/2UWLnpyjiiD8A43iUnI89EhuNFsFmLKyvp9dziV2nbuKf84Ig+AOP4aUg4dvnpArI3HDfxFoaOH8zjuoaufl0JSR96nVtg3PzqvzWPddISiiOS4xZfcsLt/ZD4iuftkyO2w/x8x/n2Dpc8UQkB7uflkPgO+18zWjD2d0YRVy6/a0axVjQXJm/D+1I/QBeecYEU4/oWOdn5nQi/m1M942eRYvxGT5i9eBP89vg2Hb7P8rp2B/drLOL2gu/rBn3aCxl+r8B49wpThUlb/IYXbnEgwPi9G7LdGDxmuyHewqRgNxAB7ufrEbEbB5o7H3K7Mkb8+ZMfecQZ7BVydP2bXi3QXRjzj8yu0r1YYWVxDtqxfdk/lPCNu34Uxv1SyHw75iL3MZvcjwUu9yupTVs8rxKulATj90ZE4l+SPfJVr/euHZVdk/nB+bmLh/u7q1/rEdErSe1o/EFefL6wuJ7LEyvW+j13/OK8rROOuT5df6rixf3VufTcanbexZ7Z8OJtnfDKkz9HPqR4W6JLPiRqiPEq9Hk85h9QNwaCPf85D3bynt5y7O/9iNgfPv6Mz7j9CY/zFzpuIeKyn+Lzj/N8nOd37+kPCg1T36kcWDd4OvFLVOJINHQ+RVzkTfUckPPhcEB8yHG1+LATedhveSJnjinekNtR2uN9o+XMfx+T6OaJHJf95PpNvD3YxW+NGmJcS31uPw/vYY8Fqxc5zk2EM+73dkTs6HNUq+qvpEccp238kbSnL5qfyvGaiAWD29ug+0Xc+lP/a8e4DvEjb6Mh4RXEOoP7AX/y4LdNRT8gz1NVux2eHP6uQo/Xy3fNx0LE40yPK96O50uUASiM0z34Owrr58EjWD9zP1U5oHhpno/u/msFLvfIeRDi+ZmNMB8PRoiP5+C8tV/17wy6B1qVTx9K8OLnpl6/iiGNq1P7OY2ueciS0zhnFX5djYDeJQ78yP2g4q+g+P/dlKjtT2Xjkvp3UUM8f1+ekP3pUa2Xc3T0K5Cj6dTvpRO+P7WN/0TuT4dQXLjqeVXGw8/G8yt4fL0kraILx49O7Y4QNyq7X+o6CSc/ehydb2K7I8tP8fu7cqp25/8BAAD//7CclxiYcQAA";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
